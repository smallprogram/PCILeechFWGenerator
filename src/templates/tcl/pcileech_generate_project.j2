{% from "_helpers.j2" import get_vendor_id, get_device_id, get_subsystem_vendor_id, get_subsystem_device_id %}
{{ header_comment }}
puts "Generating project"
set_msg_config -id {Common 17-55} -suppress
set_msg_config -id {Vivado 12-1387} -suppress

# Project configuration
set project_name "{{ project_name }}"
set project_dir "{{ project_dir }}"
set fpga_part "{{ fpga_part }}"
set board_name "{{ board_name }}"

# PCILeech directory structure
set src_dir "{{ pcileech.src_dir }}"
set ip_dir "{{ pcileech.ip_dir }}"

# Create project directory if it doesn't exist
file mkdir $project_dir

# Close any existing project to avoid conflicts
catch {close_project -quiet}

# Create Vivado project
create_project $project_name $project_dir -part $fpga_part -force

# Set project properties
set_property target_language Verilog [current_project]
set_property simulator_language Mixed [current_project]
set_property default_lib xil_defaultlib [current_project]

{% if fpga_family == "ultrascale" or fpga_family == "ultrascale_plus" %}
# UltraScale/UltraScale+ specific settings
set_property XPM_LIBRARIES {XPM_CDC XPM_MEMORY XPM_FIFO} [current_project]
{% endif %}

# Create source directory structure
file mkdir [file join $project_dir $src_dir]
file mkdir [file join $project_dir $ip_dir]

puts "Created PCILeech directory structure:"
puts "  Source directory: $src_dir"
puts "  IP directory: $ip_dir"

# Add SystemVerilog source files
{% if pcileech.source_files %}
puts "Adding SystemVerilog source files..."
{% for source_file in pcileech.source_files %}
if {[file exists "{{ source_file }}"]} {
    add_files -norecurse "{{ source_file }}"
    puts "  Added: {{ source_file }}"
} else {
    puts "  Warning: Source file not found: {{ source_file }}"
}
{% endfor %}
{% else %}
# Add all SystemVerilog files from src directory
if {[file exists $src_dir]} {
    set sv_files [glob -nocomplain [file join $src_dir "*.sv"]]
    set v_files [glob -nocomplain [file join $src_dir "*.v"]]
    
    foreach sv_file $sv_files {
        add_files -norecurse $sv_file
        puts "  Added SystemVerilog: [file tail $sv_file]"
    }
    
    foreach v_file $v_files {
        add_files -norecurse $v_file
        puts "  Added Verilog: [file tail $v_file]"
    }
}
{% endif %}

{% from "_helpers.j2" import safe_attr %}
# Configure PCIe IP Core based on FPGA family
puts "Configuring PCIe IP Core for {{ pcie_ip_type }}..."

{# default supports flags when not provided #}
{%- set _supports_msi = False -%}
{%- if supports_msi is defined %}
    {%- set _supports_msi = supports_msi -%}
{%- elif pcileech is defined and (pcileech.get('supports_msi') is defined) %}
    {%- set _supports_msi = pcileech.get('supports_msi') -%}
{%- elif device is defined and (getattr(device, 'supports_msi', None) is not none) %}
    {%- set _supports_msi = getattr(device, 'supports_msi', False) -%}
{%- endif %}

{%- set _supports_msix = False -%}
{%- if supports_msix is defined %}
    {%- set _supports_msix = supports_msix -%}
{%- elif pcileech is defined and (pcileech.get('supports_msix') is defined) %}
    {%- set _supports_msix = pcileech.get('supports_msix') -%}
{%- elif device is defined and (getattr(device, 'supports_msix', None) is not none) %}
    {%- set _supports_msix = getattr(device, 'supports_msix', False) -%}
{%- endif %}

{%- if pcie_ip_type == "axi_pcie" %}
# Custom PCIe implementation for Artix-7 35T
# This part uses custom SystemVerilog modules instead of Xilinx IP cores

# Set device-specific parameters for custom PCIe implementation
{%- if not (device.device_id if device is defined else None) or not (device.vendor_id if device is defined else None) %}
{%- error "Device ID and Vendor ID are required - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not (device.revision_id if device is defined else None) %}
{%- error "Revision ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not (device.subsys_device_id if device is defined else None) %}
{%- error "Subsystem Device ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not (device.subsys_vendor_id if device is defined else None) %}
{%- error "Subsystem Vendor ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
set DEVICE_ID 0x{{ get_device_id(device_config, device, config_space, device_id_int) }}
set VENDOR_ID 0x{{ get_vendor_id(device_config, device, config_space, vendor_id_int) }}
set REVISION_ID {{ device.revision_id }}
set SUBSYSTEM_VENDOR_ID 0x{{ get_subsystem_vendor_id(device_config, device, vendor_id_int) }}
set SUBSYSTEM_ID 0x{{ get_subsystem_device_id(device_config, device, device_id_int) }}

puts "Using custom PCIe implementation for Artix-7 35T"
puts "Device ID: $DEVICE_ID"
puts "Vendor ID: $VENDOR_ID"
puts "Revision ID: $REVISION_ID"

# No IP cores required - PCIe functionality implemented in custom SystemVerilog modules

{% elif pcie_ip_type == "pcie_ultrascale" %}
# UltraScale PCIe IP
create_ip -name pcie4_uscale_plus -vendor xilinx.com -library ip -module_name pcie_ultrascale_bridge
{%- if not device.device_id or not device.vendor_id %}
{%- error "Device ID and Vendor ID are required - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not device.revision_id %}
{%- error "Revision ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not device.subsys_device_id %}
{%- error "Subsystem Device ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not device.subsys_vendor_id %}
{%- error "Subsystem Vendor ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not device.class_code %}
{%- error "Class Code must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
set_property -dict [list \
    CONFIG.PL_LINK_CAP_MAX_LINK_SPEED {8.0_GT/s} \
    CONFIG.PL_LINK_CAP_MAX_LINK_WIDTH {X{{ max_lanes }}} \
    CONFIG.AXISTEN_IF_EXT_512_RQ_STRADDLE {false} \
    CONFIG.PF0_DEVICE_ID 0x{{ get_device_id(device_config, device, config_space, device_id_int) }} \
    CONFIG.PF0_VENDOR_ID 0x{{ get_vendor_id(device_config, device, config_space, vendor_id_int) }} \
    CONFIG.PF0_CLASS_CODE {{ device.class_code }} \
    CONFIG.PF0_REVISION_ID {{ device.revision_id }} \
    CONFIG.PF0_SUBSYSTEM_ID 0x{{ get_subsystem_device_id(device_config, device, device_id_int) }} \
    CONFIG.PF0_SUBSYSTEM_VENDOR_ID 0x{{ get_subsystem_vendor_id(device_config, device, vendor_id_int) }} \
    CONFIG.PF0_BAR0_ENABLED {true} \
    CONFIG.PF0_BAR0_64BIT {true} \
    CONFIG.PF0_BAR0_SIZE {1} \
    CONFIG.PF0_MSI_ENABLED {% if _supports_msi %}{true}{% else %}{false}{% endif %} \
    CONFIG.PF0_MSIX_ENABLED {% if _supports_msix %}{true}{% else %}{false}{% endif %} \
] [get_ips pcie_ultrascale_bridge]

{% else %}
# TEMPLATE FILE: /src/templates/tcl/pcileech_generate_project.j2
# 7-Series PCIe IP (default)
create_ip -name pcie_7x -vendor xilinx.com -library ip -module_name pcie_7x_bridge
{%- if not device.device_id or not device.vendor_id %}
{%- error "Device ID and Vendor ID are required - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not device.revision_id %}
{%- error "Revision ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not device.subsys_device_id %}
{%- error "Subsystem Device ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
{%- if not device.subsys_vendor_id %}
{%- error "Subsystem Vendor ID must be derived from donor device - no fallback values allowed to prevent generic firmware" %}
{%- endif %}
set_property -dict [list \
    CONFIG.Link_Speed {2.5_GT/s} \
    CONFIG.Maximum_Link_Width X1 \
    CONFIG.Device_ID 0x{{ get_device_id(device_config, device, config_space, device_id_int) }} \
    CONFIG.Vendor_ID 0x{{ get_vendor_id(device_config, device, config_space, vendor_id_int) }} \
    CONFIG.Revision_ID {{ device.revision_id }} \
    CONFIG.Class_Code_Base {02} \
    CONFIG.Class_Code_Interface {00} \
    CONFIG.Class_Code_Sub {00} \
    CONFIG.Subsystem_ID 0x{{ get_subsystem_device_id(device_config, device, device_id_int) }} \
    CONFIG.Subsystem_Vendor_ID 0x{{ get_subsystem_vendor_id(device_config, device, vendor_id_int) }} \
    CONFIG.Bar0_Enabled {true} \
    CONFIG.Bar0_Type {Memory} \
    CONFIG.Bar0_64bit {true} \
    CONFIG.Bar0_Size {1}{% if supports_msi %} \
    CONFIG.MSI_Enabled {true}{% endif %}{% if supports_msix %} \
    CONFIG.MSIx_Enabled {true}{% endif %} \
] [get_ips pcie_7x_bridge]
{% endif %}

# Add IP files to project
{% if pcileech.ip_files %}
puts "Adding IP core files..."
{% for ip_file in pcileech.ip_files %}
if {[file exists "{{ ip_file }}"]} {
    add_files -norecurse "{{ ip_file }}"
    puts "  Added IP: {{ ip_file }}"
} else {
    puts "  Warning: IP file not found: {{ ip_file }}"
}
{% endfor %}
{% endif %}

# Add coefficient files if present
{% if pcileech.coefficient_files %}
puts "Adding coefficient files..."
{% for coeff_file in pcileech.coefficient_files %}
if {[file exists "{{ coeff_file }}"]} {
    add_files -norecurse "{{ coeff_file }}"
    puts "  Added coefficient file: {{ coeff_file }}"
} else {
    puts "  Warning: Coefficient file not found: {{ coeff_file }}"
}
{% endfor %}
{% endif %}

# Add constraint files
puts "Adding constraint files..."
{% if constraint_files %}
{% for constraint_file in constraint_files %}
if {[file exists "{{ constraint_file }}"]} {
    add_files -fileset constrs_1 -norecurse "{{ constraint_file }}"
    puts "  Added constraint: {{ constraint_file }}"
} else {
    puts "  Warning: Constraint file not found: {{ constraint_file }}"
}
{% endfor %}
{% else %}
# Add all XDC files from current directory
set xdc_files [glob -nocomplain "*.xdc"]
foreach xdc_file $xdc_files {
    add_files -fileset constrs_1 -norecurse $xdc_file
    puts "  Added constraint: [file tail $xdc_file]"
}
{% endif %}

# Set top-level module
{% if pcileech.source_files and pcileech.source_files|length > 0 %}
# Try to determine top module from first source file
set top_module [file rootname [file tail "{{ pcileech.source_files[0] }}"]]
{% else %}
# Use PCILeech top-level wrapper as default
set top_module "pcileech_top"
{% endif %}

# Set source management mode to manual before setting top
set_property source_mgmt_mode None [current_project]
if {$top_module != ""} {
    set_property top $top_module [current_fileset]
    puts "Set top module: $top_module"
} else {
    puts "Top module will be auto-detected by Vivado"
}

# Update compile order
update_compile_order -fileset sources_1

# Generate IP cores
puts "Generating IP cores..."
generate_target all [get_files *.xci]
catch {config_ip_cache -export [get_ips -all]}

# Skip validation (validate_design is not available in all Vivado versions)
puts "Skipping design validation..."
# validate_design -quiet

puts "PCILeech project generation completed successfully!"
puts "Project: $project_name"
puts "Location: $project_dir"
puts "FPGA Part: $fpga_part"
puts "PCIe IP Type: {{ pcie_ip_type }}"
puts "Max Lanes: {{ max_lanes }}"
{% if supports_msi %}
puts "MSI Support: Enabled"
{% endif %}
{% if supports_msix %}
puts "MSI-X Support: Enabled"
{% endif %}

puts "Project setup completed. Ready for build phase."
