[
  
    
    {
      "title"    : "Configuration Space Shadow BRAM",
      "category" : "",
      "tags"     : "",
      "url"      : "/config-space-shadow.html",
      "date"     : "",
      "content"  : ""Configuration Space Shadow BRAM ImplementationThis document describes the implementation of the full 4 KB configuration space shadow in BRAM for the PCILeech FPGA firmware generator.OverviewThe configuration space shadow BRAM implementation provides a complete 4 KB PCI Express configuration space in block RAM (BRAM) on the FPGA. This is a critical component for PCIe device emulation, as it allows the PCILeech firmware to accurately respond to configuration space accesses from the host system.Key features:  Full 4 KB configuration space shadow in BRAM  Dual-port access for simultaneous read/write operations  Overlay RAM for writable fields (Command/Status registers)  Initialization from device configuration data or synthetic generation  Little-endian format compatible with PCIe specification  Automatic overlay mapping for writable registersArchitectureThe implementation consists of the following components:  Configuration Space BRAM: A 4 KB block RAM that stores the entire configuration space of the emulated PCIe device.  Overlay RAM: A smaller RAM that stores writable fields, allowing the host to modify certain configuration registers.  State Machine: Handles PCIe configuration space access requests (reads and writes).  Overlay Mapper: Automatically detects which registers need overlay entries based on PCIe specifications.SystemVerilog Modules  pcileech_tlps128_cfgspace_shadow.sv: The main module implementing the configuration space shadow.  pcileech_tlps128_bar_controller.sv: The BAR controller that interfaces with the configuration space shadow.Configuration Space GenerationThe configuration space is generated through multiple methods depending on the available data:1. VFIO-based Configuration Space ReadingFor devices bound to VFIO drivers, the system reads the actual configuration space:  The ConfigSpaceManager class handles VFIO device binding and configuration space access.  Configuration space is read via VFIO region info queries or sysfs fallback.  The raw configuration space data is extracted and validated.  Extended configuration space (up to 4 KB) is supported when available.2. Synthetic Configuration Space GenerationWhen VFIO data is not available, the system generates synthetic configuration space:  The ConfigSpaceManager.generate_synthetic_config_space() method creates a complete 4 KB configuration space.  Device identification data is populated from device profiles.  Standard PCI header fields are generated with appropriate defaults.  Capability structures (MSI, MSI-X, PCIe) are added based on device requirements.  BAR configurations are populated based on device analysis.3. Configuration Space InitializationThe generated configuration space is converted to FPGA-compatible format:  The ConfigSpaceHexFormatter class converts binary data to hex format.  Data is formatted as 32-bit words in little-endian format.  A config_space_init.hex file is generated for SystemVerilog $readmemh initialization.  Comments are added for debugging and register identification.Overlay RAM for Writable FieldsThe overlay RAM provides a mechanism for handling writable fields in the configuration space. The OverlayMapper class automatically detects which registers need overlay entries based on PCIe specifications:Automatic Overlay DetectionThe system automatically identifies writable registers:  Standard PCI registers: Command, Status, Cache Line Size, Latency Timer, BIST  BAR registers: Detected as special handling type with size-based masks  Capability registers: MSI, MSI-X, PCIe capability registers with mixed read/write fields  Extended capabilities: AER, Power Management, and other extended capabilitiesOverlay OperationWhen reading from a register with writable fields:  The base value is read from the main configuration space BRAM  The overlay mask determines which bits come from overlay RAM  The final value combines: (base_value &amp; ~mask) | (overlay_value &amp; mask)When writing to a register with writable fields:  Only the writable bits (defined by the mask) are updated in overlay RAM  Read-only bits remain unchanged in the base configuration spaceIntegration with Build ProcessThe configuration space shadow is integrated into the build process through the PCILeechGenerator and template system:Template-based Generation  Template Context Building: The PCILeechContextBuilder creates a comprehensive template context containing:          Device configuration data from VFIO or synthetic generation      Overlay mapping automatically generated by OverlayMapper      Extended configuration space pointers      MSI-X and capability configurations        SystemVerilog Generation: The AdvancedSVGenerator processes templates to create:          Configuration space shadow module (cfg_shadow.sv)      Configuration space initialization file (config_space_init.hex)      Overlay constants and lookup tables        Hex File Generation: The ConfigSpaceHexFormatter converts configuration space data to:          Little-endian 32-bit words      Vivado-compatible hex format      Debug comments for register identification      Build Integration  The configuration space shadow module is automatically included in the generated TCL script.  The config_space_init.hex file is included in the project for BRAM initialization.  Overlay constants are generated as SystemVerilog parameters for efficient lookup.SystemVerilog Implementation DetailsConfiguration Space Shadow ModuleThe main module (pcileech_tlps128_cfgspace_shadow) implements:  Dual-port BRAM: Main configuration space storage with parameterized size  Overlay RAM: Separate storage for writable fields with automatic indexing  State Machine: Handles PCIe configuration reads/writes with overlay logic  Shadow Control: Determines when to use shadow vs. hardware based on address rangesKey Features  Automatic Overlay Mapping: Lookup tables generated from OVERLAY_MAP template data  Byte-enable Support: Proper handling of partial register writes  Extended Configuration Space: Support for capabilities beyond standard 256 bytes  CFGTLP Integration: Proper integration with PCIe configuration TLP handlingTestingThe implementation includes comprehensive testing:  Python Unit Tests:          test_config_space_manager.py: Tests for configuration space reading and generation      test_overlay_mapper.py: Tests for overlay detection and mapping      test_hex_formatter.py: Tests for hex file generation and formatting        Integration Tests:          VFIO binding and configuration space access      Synthetic configuration space generation      Template rendering and context building      UsageThe configuration space shadow is automatically included in the build process. The system:  Detects Device Configuration: Automatically reads from VFIO or generates synthetic data  Maps Overlay Requirements: Automatically detects which registers need overlay entries  Generates SystemVerilog: Creates the shadow module with proper initialization  Integrates with Build: Includes all necessary files in the FPGA projectConfiguration OptionsThe system supports various configuration options:  CONFIG_SPACE_SIZE: Parameterized size (256 bytes to 4 KB)  OVERLAY_ENTRIES: Number of overlay RAM entries (automatically calculated)  EXT_CFG_CAP_PTR: Extended capability pointer offset  DUAL_PORT: Optional dual-port BRAM configurationLimitations  The current implementation supports a single PCIe function (function 0).  Overlay RAM has a practical limit based on FPGA resources.  Extended capabilities are limited to commonly used types.Future EnhancementsPossible future enhancements include:  Support for multiple PCIe functions  Dynamic reconfiguration of the configuration space  Enhanced error handling and reporting  Support for device-specific extended capabilities""
    },
    
  
    
    {
      "title"    : "Development Guide",
      "category" : "",
      "tags"     : "",
      "url"      : "/development.html",
      "date"     : "",
      "content"  : ""ğŸ› ï¸ Development GuideThe code needs to run on linux but can be developed anywhere with a python vers &gt;3.9# Clone repositorygit clone https://github.com/ramseymcgrath/PCILeechFWGeneratorcd PCILeechFWGenerator# Create virtual environmentpython3 -m venv venvsource venv/bin/activate  # On Windows: venv\\Scripts\\activate# Install development dependenciespip install -r requirements-dev.txt# Install pre-commit hookspre-commit install# Run testspytest tests/ğŸ“¦ Building from Source# Build distributionspython -m build# Install locallypip install dist/*.whlUnit testingTUI Tests are next to the code in the tui dir, app tests are in the tests/ dir.make test in the repo is the easiest way to run unit tests locally. The github action will run them in CI.ğŸ¤ ContributingWe welcome contributions! Please see CONTRIBUTING.md for detailed guidelines.Quick Start:  Fork the repository  Create a feature branch (git checkout -b feature/amazing-feature)  Make your changes  Add tests for new functionality  Run the test suite (pytest)  Commit your changes (git commit -m 'feat: add amazing feature')  Push to the branch (git push origin feature/amazing-feature)  Open a Pull RequestğŸ§ª TestingThe project uses pytest for testing. Run the test suite with:# Run all testspytest# Run specific test filepytest tests/test_specific_module.py# Run with coveragepytest --cov=src tests/ğŸ“ Code StyleThis project follows these coding standards:  PEP 8 for Python code style  Black for code formatting  isort for import sorting  flake8 for linting  mypy for type checkingPre-commit hooks are configured to enforce these standards.ğŸ”§ Device Driver ManagementVFIO-PCI BindingThe firmware generator manages PCIe device drivers during the build process. Here are some important implementation details:  Driver Detection: The system checks the current driver bound to a device before attempting to bind it to vfio-pci  Automatic Skip: If a device is already bound to vfio-pci, the binding process is skipped automatically  Error Handling: Even if the bind command fails but the device is actually bound to vfio-pci, the system will detect this and continue  Driver Restoration: After the build completes, the system attempts to restore the original driverThis approach ensures smooth operation even in edge cases like:  Multiple consecutive builds using the same device  Manual pre-binding of devices to vfio-pci  Race conditions during driver bindingâš ï¸ DisclaimerThis tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.Version 0.5.0 - Major release with TUI interface and professional packaging""
    },
    
  
    
    {
      "title"    : "Device Cloning",
      "category" : "",
      "tags"     : "",
      "url"      : "/device-cloning.html",
      "date"     : "",
      "content"  : ""Device CloningThe device cloning process creates an FPGA-based replica of a PCIe device through systematic hardware analysis and template generation. This section details the multi-stage process and error handling mechanisms.Prerequisites and System RequirementsBefore cloning begins, the system must meet specific requirements:  IOMMU Support: Intel VT-d or AMD-Vi must be enabled in BIOS/UEFI  Kernel Configuration: VFIO modules loaded (vfio, vfio-pci, vfio_iommu_type1)  Root Privileges: Required for VFIO device binding operations  Fallback Mode: For testing environments without IOMMU, use iommu=pt or vfio.enable_unsafe_noiommu_mode=1Stage 1: VFIO Device AcquisitionThe generator establishes exclusive control over the target PCIe device through Linux VFIO:  IOMMU Group Discovery: Identifies all devices sharing the same IOMMU group as the target BDF (e.g., 0000:01:00.0)  Driver Unbinding: Safely unbinds existing kernel drivers from all group members  VFIO Binding: Rebinds devices to the vfio-pci driver for userspace access  Handle Creation: Establishes /dev/vfio/&lt;group&gt; interface for safe device interactionError Handling:  IOMMU Unavailable: Falls back to heuristic size estimation (requires explicit enablement)  Driver Conflicts: Automatically handles in-use drivers with graceful fallback  Permission Errors: Provides clear diagnostic messages for privilege escalationStage 2: Configuration Space AnalysisThe generator performs comprehensive configuration space extraction:Standard PCI Header (0x00-0xFF)  Device Identity: Vendor ID, Device ID, Subsystem IDs, Class Code, Revision  Command/Status: Capability flags, error status, device state  BAR Registers: Base Address Registers 0-5 with size and type information  Interrupt Configuration: Legacy INTx pin assignmentsExtended Configuration Space (0x100-0xFFF)  Capability Structures: MSI/MSI-X, Power Management, PCIe-specific capabilities  Vendor-Specific: Custom capability blocks preserved byte-for-byte  Advanced Features: AER, VC, PASID, and other modern PCIe capabilitiesValidation and Security:  Checksum Generation: SHA-256 hash of configuration space prevents generic firmware  Signature Verification: Ensures unique firmware per donor device  Sanitization: Removes potentially sensitive vendor-specific data when requestedStage 3: BAR Discovery and Memory MappingSystematic analysis of Base Address Registers determines memory layout:For each BAR index (0-5):â”œâ”€â”€ Issue VFIO_DEVICE_GET_REGION_INFO ioctlâ”œâ”€â”€ Extract: size, read/write permissions, mmap capabilityâ”œâ”€â”€ Filter: Ignore I/O ports and zero-sized regionsâ”œâ”€â”€ Record: All valid MMIO BARs with metadataâ””â”€â”€ Select: Largest MMIO BAR as primary windowAdvanced BAR Handling:  64-bit BARs: Properly handles paired 32-bit registers  Prefetchable Memory: Preserves caching hints and optimization flags  Size Validation: Ensures BAR sizes are power-of-2 aligned  Conflict Resolution: Handles overlapping or invalid BAR configurationsFallback Mechanisms:  Heuristic Sizing: When VFIO fails, estimates BAR sizes from register patterns  Conservative Defaults: Uses safe minimum sizes for critical BARs  Manual Override: Allows explicit BAR configuration via command-line parametersStage 4: Interrupt Architecture AnalysisThe generator determines optimal interrupt emulation strategy:Priority Order (Highest to Lowest)  MSI-X: Multi-vector message signaled interrupts          Validates table size &gt; 0      Preserves vector count and table structure      Maps interrupt vectors to FPGA resources        MSI: Single-vector message signaled interrupts          Fallback when MSI-X unavailable      Simpler implementation with single interrupt line        Legacy INTx: Pin-based interrupts          Last resort for older devices      Emulates traditional interrupt sharing      Capability Validation:  Table Size Verification: Ensures MSI-X table is properly sized  Vector Count Limits: Respects hardware and software constraints  Interrupt Routing: Validates interrupt pin assignmentsStage 5: Template Context GenerationAll extracted data is consolidated into a comprehensive template context:Core Components  Device Identity: Complete PCI configuration header  Memory Layout: BAR map with sizes, types, and access patterns  Interrupt Configuration: Selected interrupt mechanism with parameters  Timing Parameters: Clock domains, reset sequences, power states  Feature Flags: DMA capabilities, error handling, debug interfacesValidation PipelineContext Validation:â”œâ”€â”€ Required Fields Checkâ”‚   â”œâ”€â”€ Non-zero Vendor IDâ”‚   â”œâ”€â”€ Valid Device Classâ”‚   â””â”€â”€ Usable MMIO BAR presentâ”œâ”€â”€ Consistency Verificationâ”‚   â”œâ”€â”€ BAR size alignmentâ”‚   â”œâ”€â”€ Capability chain integrityâ”‚   â””â”€â”€ Interrupt configuration validityâ””â”€â”€ Security Validation    â”œâ”€â”€ Signature uniqueness    â”œâ”€â”€ No default/generic patterns    â””â”€â”€ Sanitized vendor dataError Recovery:  Missing BARs: Provides synthetic minimal BAR configuration  Invalid Capabilities: Gracefully degrades to simpler interrupt modes  Corrupted Data: Attempts repair or fails with detailed diagnosticsStage 6: Firmware GenerationThe validated context drives the Jinja2/SystemVerilog template engine:Output Artifacts  FPGA Bitstream: Device-specific .bit or .bin file  Configuration Headers: C/C++ headers for host software integration  JSON Metadata: Machine-readable device description  Build Reports: Synthesis timing, resource utilization, verification resultsQuality Assurance  Template Validation: Ensures generated Verilog is syntactically correct  Resource Estimation: Predicts FPGA utilization before synthesis  Timing Analysis: Validates clock domain crossings and setup/hold timesQuick Start Command# Enable IOMMU and run generatorsudo python3 pcileech.py build --bdf 0000:01:00.0 --board pcileech_35t325_x4""
    },
    
  
    
    {
      "title"    : "Firmware Uniqueness",
      "category" : "",
      "tags"     : "",
      "url"      : "/firmware-uniqueness.html",
      "date"     : "",
      "content"  : ""Uniqueness OverviewThe PCILeech firmware generator creates authentic hardware clones by performing byte-perfect replication of donor device characteristics while maintaining a stable, reusable core architecture. The result is hardware that appears identical to the original device from the host OS perspective while providing consistent, predictable behavior across builds.Key Benefits  Perfect Stealth: Identical PCIe fingerprints to donor hardware  Build Consistency: Same core IP across all generated firmware  Research Flexibility: Safe testing environment for security research  Driver Compatibility: Native vendor driver support without modificationsDeep-Cloned Device AnatomyThe cloning process replicates critical hardware characteristics across multiple layers:            Layer      Cloned Components      Security Impact      Implementation Notes                  PCIe Config Space      256-byte header + Extended Capabilities (PM, MSI/MSI-X, PCIe, VSEC)      Driver whitelisting, BIOS compatibility      Missing capabilities trigger Code 10 errors              BAR &amp; Memory Map      BAR0-BAR5 sizes, flags, alignment, prefetch settings      Fingerprint resistance      BAR entropy analysis defeated              Interrupt Topology      MSI/MSI-X tables, indices, masks, PBA configuration      IRQ behavior matching      BRAM-mirrored for consistency              Link Behavior      L0s/L1 timings, Max_Read_Request, advanced PCIe features      Advanced fingerprinting      ASPM, OBFF, Hot-plug states              Power &amp; Error Handling      ASPM policies, PME support, D-states, AER masks      Enterprise compliance      Byte-perfect POST auditing      Configuration Space LayoutOffset 0x00-0xFF: Standard PCIe Header (256 bytes)â”œâ”€â”€ 0x00-0x3F: Type 0/1 Configuration Headerâ”œâ”€â”€ 0x40-0xFF: Capability Structuresâ””â”€â”€ 0x100+:    Extended Capability StructuresExtended Capabilities Chain:â”œâ”€â”€ Power Management (PM)â”œâ”€â”€ Message Signaled Interrupts (MSI/MSI-X)  â”œâ”€â”€ PCIe Capability Structureâ”œâ”€â”€ Vendor Specific Extended Capability (VSEC)â””â”€â”€ Advanced Error Reporting (AER)Build-Time Security FeaturesEntropy Generation  Unique Bitstreams: SHA-256 hash of donor configuration salted into unused BRAM  Forensic Tracking: Vivado version and build timestamp embedded in hidden VSEC  P&amp;R Randomization: IO placement randomized within timing constraints  Anti-Analysis: Defeats simple bitstream diffing and pattern recognitionImplementation Details// Example: Build-time entropy injectionlocalparam [255:0] BUILD_ENTROPY = 256'h{SHA256_HASH};localparam [63:0]  BUILD_TIMESTAMP = 64'h{UNIX_TIMESTAMP};// Hidden in unused VSEC register spaceassign vsec_entropy_reg = BUILD_ENTROPY[31:0];assign vsec_timestamp_reg = BUILD_TIMESTAMP[31:0];Detection-Resistance ValidationAutomated Testing Matrix            Test Category      Tool/Method      Expected Behavior      Failure Indicators                  Basic Enumeration      lspci -vvv, pcieutils      Identical vendor/device IDs, capability offsets      Mismatched PCI IDs, capability gaps              Driver Loading      Windows Device Manager, Linux modprobe      Native vendor driver loads without warnings      Code 10 errors, unsigned driver prompts              Stress Testing      MSI flood tests, hot-reset cycles      Stable operation under load      System hangs, IRQ storms              Security Scanning      Anti-tamper suites (Falcon, Ranger)      No anomaly alerts      Link state mismatches, timing deviations              Power Management      ASPM state transitions, D-state cycling      Identical power behavior to donor      PME assertion failures, ASPM violations      Validation Scripts#!/bin/bash# Basic validation suiteecho \"=== PCIe Device Validation ===\"# Check PCI configuration spacelspci -s $DEVICE_BDF -vvv &gt; current_config.txtdiff -u donor_config.txt current_config.txt# Verify driver loadingif lsmod | grep -q $EXPECTED_DRIVER; then    echo \"âœ“ Driver loaded successfully\"else    echo \"âœ— Driver loading failed\"fi# Test MSI-X functionality  echo \"Testing interrupt handling...\"./test_msix_vectors $DEVICE_BDFImmutable Core ArchitectureThe firmware maintains a stable core while adapting the peripheral interface:â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚           Donor-Specific Shell          â”‚ â† Cloned: IDs, BARs, MSI-Xâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚              Stable Core IP             â”‚ â† Consistent across buildsâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚â”‚  â”‚        AXI-PCIe Bridge              â”‚ â”‚ â† Single timing closureâ”‚  â”‚  â€¢ TLP packet processing           â”‚ â”‚â”‚  â”‚  â€¢ Configuration space handler     â”‚ â”‚â”‚  â”‚  â€¢ Completion timeout logic        â”‚ â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚â”‚  â”‚        DMA Scatter-Gather           â”‚ â”‚ â† Shared test benchesâ”‚  â”‚  â€¢ Descriptor ring management      â”‚ â”‚â”‚  â”‚  â€¢ Memory protection checks        â”‚ â”‚â”‚  â”‚  â€¢ Bandwidth throttling            â”‚ â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚â”‚  â”‚      Debug &amp; Monitoring             â”‚ â”‚ â† Identical CSR mapâ”‚  â”‚  â€¢ UART/JTAG interfaces            â”‚ â”‚â”‚  â”‚  â€¢ Performance counters            â”‚ â”‚â”‚  â”‚  â€¢ ECC status registers            â”‚ â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜Core IP Benefits  Timing Closure: Single PLL domain, pre-verified timing constraints  Test Coverage: Shared test benches across all device variants  Debug Consistency: Identical register map for all builds  Maintenance: Core updates propagate to all device typesPerformance MetricsResource Utilization            Metric      Artix-7 35T      Artix-7 75T      Artix-7 100T      Variation      Notes                  Fmax      150 MHz      165 MHz      175 MHz      Â±5%      Single PLL domain              LUT Utilization      85%      45%      35%      Â±3% donor variance      BAR decode depth only              BRAM Usage      44 Ã— 36Kb      44 Ã— 36Kb      44 Ã— 36Kb      Fixed      MSI-X tables + buffers              DSP Slices      12      12      12      Fixed      DMA checksum engines              Static Power      180mW      200mW      220mW      Â±20mW      Temperature dependent      Timing Analysis# Critical path constraintscreate_clock -period 6.667 -name pcie_clk [get_ports pcie_clk_p]set_input_delay -clock pcie_clk -max 2.0 [get_ports pcie_rx_p]set_output_delay -clock pcie_clk -max 2.0 [get_ports pcie_tx_p]# Cross-clock domain constraintsset_clock_groups -asynchronous -group [get_clocks pcie_clk] -group [get_clocks user_clk]Security &amp; Research ApplicationsUse Case Matrix            Role      Application      Implementation      Risk Mitigation                  Red Team      Hardware implants, DMA attacks      Covert data exfiltration via cloned capture cards      Air-gapped testing, legal authorization              Blue Team      SIEM tuning, anomaly detection      Generate realistic traffic without production risk      Isolated lab networks, controlled scenarios              Academia      PCIe security research      TLP poisoning, IOMMU bypass studies      Ethical review, responsible disclosure              Tool Vendors      Legacy hardware validation      Driver testing against discontinued hardware      Licensing compliance, IP protection              Forensics      Evidence preservation      Bit-perfect hardware replication for analysis      Chain of custody, legal admissibility      Research Scenarios# Example: DMA attack simulationclass DMAAttackSimulator:    def __init__(self, target_device):        self.device = target_device        self.memory_map = self.scan_physical_memory()        def extract_credentials(self):        \"\"\"Simulate credential extraction via DMA\"\"\"        for region in self.memory_map:            if self.contains_sensitive_data(region):                yield self.extract_region(region)        def inject_payload(self, payload):        \"\"\"Simulate code injection via DMA writes\"\"\"        target_addr = self.find_executable_region()        return self.device.dma_write(target_addr, payload)Troubleshooting &amp; Error HandlingCommon Issues &amp; SolutionsBuild-Time Errors            Error      Cause      Solution      Prevention                  Timing Closure Failure      Complex donor BAR decode logic      Reduce Fmax target, pipeline critical paths      Pre-validate donor complexity              Resource Overflow      Large MSI-X tables on small FPGAs      Use external memory for tables      Check resource requirements early              P&amp;R Failure      IO pin conflicts      Adjust pin assignments, use different package      Validate pinout before synthesis      Runtime Issues            Symptom      Likely Cause      Diagnostic Steps      Fix                  Code 10 Error      Missing/incorrect capabilities      Compare lspci output with donor      Update capability chain              IRQ Storm      MSI-X table corruption      Check interrupt vectors with /proc/interrupts      Rebuild MSI-X configuration              DMA Timeout      Incorrect BAR mapping      Verify memory regions with /proc/iomem      Fix BAR size/alignment              Link Training Failure      PCIe electrical issues      Check link status with setpci      Verify signal integrity      Debug Infrastructure// Integrated debug featuresmodule debug_controller (    input wire clk,    input wire rst_n,        // Debug interfaces    output wire [31:0] debug_status,    output wire [63:0] error_counters,    input wire [31:0] debug_control,        // UART debug output    output wire uart_tx,    input wire uart_rx);// Performance monitoringalways @(posedge clk) begin    if (!rst_n) begin        pcie_tlp_count &lt;= 0;        dma_transfer_count &lt;= 0;        error_count &lt;= 0;    end else begin        if (tlp_valid) pcie_tlp_count &lt;= pcie_tlp_count + 1;        if (dma_done) dma_transfer_count &lt;= dma_transfer_count + 1;        if (error_detected) error_count &lt;= error_count + 1;    endendBest PracticesDevelopment Workflow  Donor Analysis: Thoroughly characterize donor device before cloning  Incremental Testing: Validate each capability block individually  Regression Testing: Maintain test suite for all supported donors  Version Control: Tag bitstreams with donor fingerprints  Documentation: Maintain detailed build logs and test resultsSecurity Considerations  Isolation: Test in air-gapped environments  Backup: Always preserve original donor firmware  Validation: Verify cloned behavior matches donor exactly  Monitoring: Log all device interactions for analysis  Updates: Regularly update against new detection methodsLegal &amp; Ethical Considerationsâš ï¸ Critical Warnings            Risk Category      Concern      Mitigation                  Legal Compliance      Hardware impersonation may violate local laws      Consult legal counsel, obtain proper authorization              Network Security      Unauthorized device deployment      Use only in authorized test environments              Intellectual Property      Donor firmware may be copyrighted      Respect vendor IP rights, fair use only              Safety      Malformed firmware can damage hardware      Maintain serial console access, backup procedures      Responsible Use Guidelines  Authorization: Obtain explicit permission before deploying on any network  Disclosure: Follow responsible disclosure for security vulnerabilities  Documentation: Maintain detailed logs of all testing activities  Isolation: Use dedicated test hardware and networks  Backup: Always preserve original firmware before modificationsEmergency Procedures#!/bin/bash# Emergency recovery proceduresecho \"=== Emergency Recovery ===\"# Restore original firmwareif [ -f \"donor_backup.bin\" ]; then    echo \"Restoring donor firmware...\"    flashrom -p internal -w donor_backup.binfi# Reset PCIe subsystemecho \"Resetting PCIe...\"echo 1 &gt; /sys/bus/pci/devices/$DEVICE_BDF/removeecho 1 &gt; /sys/bus/pci/rescan# Check system stabilitydmesg | tail -20ConclusionThe PCILeech firmware generator provides a robust foundation for security research and hardware analysis through authentic device cloning. By maintaining perfect external compatibility while ensuring internal consistency, it enables safe, reproducible testing scenarios that would be impossible with original hardware.Key Takeaways:  Byte-perfect cloning ensures undetectable operation  Immutable core architecture provides build consistency  Comprehensive validation prevents deployment issues  Responsible use requires proper authorization and safety measures""
    },
    
  
    
    {
      "title"    : "Home",
      "category" : "",
      "tags"     : "",
      "url"      : "/",
      "date"     : "",
      "content"  : ""PCILeech Firmware GeneratorGenerate authentic PCIe DMA firmware from real donor hardware with a single command. This tool extracts donor configurations from a local device and generates unique PCILeech FPGA bitstreams (and optionally flashes a DMA card over USB-JTAG).  Warning: This tool requires real hardware. The templates are built using the device identifiers directly from a donor card and placeholder values are explicitly avoided. Using your own donor device ensures your firmware will be unique.âœ¨ Key Features  Donor Hardware Analysis: Extract real PCIe device configurations and register maps from live hardware via VFIO  Full 4KB Config-Space Shadow: Complete configuration space emulation with BRAM-based overlay memory  MSI-X Table Replication: Exact replication of MSI-X tables from donor devices with interrupt delivery logic  Deterministic Variance Seeding: Consistent hardware variance based on device serial number for unique firmware  Advanced SystemVerilog Generation: Comprehensive PCIe device controller with modular template architecture  Active Device Interrupts: MSI-X interrupt controller with timer-based and event-driven interrupt generation  Memory Overlay Mapping: BAR dispatcher with configurable memory regions and custom PIO windows  Interactive TUI: Modern Textual-based interface with real-time device monitoring and guided workflows  Containerized Build Pipeline: Podman-based synthesis environment with automated VFIO setup  Automated Testing and Validation: Comprehensive test suite with SystemVerilog assertions and Python unit tests  USB-JTAG Flashing: Direct firmware deployment to DMA boards via integrated flash utilities            ğŸ“š Complete Documentation      ğŸ—ï¸ Device Cloning Guide      ğŸ”§ Development Setup      ğŸš€ Quick StartInstallation# Install with TUI support (recommended)pip install pcileechfwgenerator[tui]# Load required kernel modulessudo modprobe vfio vfio-pciRequirements  Python â‰¥ 3.9  Donor PCIe card (any inexpensive NIC, sound, or capture card)  Linux OS (You need this)Optional Requirements  Podman (not Docker - required for proper PCIe device mounting) You use podman or run the python locally. *You must use linux for either option  DMA board (pcileech_75t484_x1, pcileech_35t325_x4, or pcileech_100t484_x1) You donâ€™t need to flash your firmware with this tooling but you can.  Vivado Studio (2022.2+ for synthesis and bitstream generation) You can use a locally generated Vivado project or insert the files into an existing one.Basic Usage# Interactive TUI (recommended for first-time users)sudo python3 pcileech.py tui# CLI interface for scripted buildssudo python3 pcileech.py build --bdf 0000:03:00.0 --board pcileech_35t325_x1# Check VFIO configurationsudo python3 pcileech.py check --device 0000:03:00.0# Flash firmware to devicesudo python3 pcileech.py flash output/firmware.bin  Note: The legacy entrypoint has been removed, please see the steps above and update your scripts accordinglyDevelopment from Repositorygit clone https://github.com/ramseymcgrath/PCILeechFWGenerator.gitcd PCILeechFWGeneratorpython3 -m venv .venv &amp;&amp; source .venv/bin/activatepip install -r requirements.txtsudo -E python3 pcileech.py tuiğŸ”§ TroubleshootingVFIO Setup Issues  Warning: Avoid using on-board devices (audio, graphics cards) for donor info. The VFIO process can lock the bus during extraction and cause system reboots.The most common issues involve VFIO (Virtual Function I/O) configuration. Use the built-in diagnostic tool:# Check VFIO setup and device compatibilitysudo python3 pcileech.py check# Check a specific devicesudo python3 pcileech.py check --device 0000:03:00.0# Interactive mode with guided fixessudo python3 pcileech.py check --interactive# Attempt automatic fixessudo python3 pcileech.py check --fixCommon VFIO Problems1. IOMMU not enabled in BIOS/UEFI# Enable VT-d (Intel) or AMD-Vi (AMD) in BIOS settings# Then add to /etc/default/grub GRUB_CMDLINE_LINUX:# For Intel: intel_iommu=on# For AMD: amd_iommu=onsudo update-grub &amp;&amp; sudo reboot2. VFIO modules not loadedsudo modprobe vfio vfio_pci vfio_iommu_type13. Device not in IOMMU group# Check IOMMU groupsfind /sys/kernel/iommu_groups/ -name '*' -type l | grep YOUR_DEVICE_BDF4. Permission issues# Add user to required groupssudo usermod -a -G vfio $USERsudo usermod -a -G dialout $USER  # For USB-JTAG accessInstallation Issues# If pip installation failspip install --upgrade pip setuptools wheelpip install pcileechfwgenerator[tui]# For TUI dependenciespip install textual rich psutil watchdog# Container issuespodman --versionpodman info | grep rootless  Note: If you run into issues with your vivado project file formatting, first clear out all your cached files and rerun. Otherwise try pulling a copy of the pcileech repo directly and then inserting the generator output in.ğŸ“š DocumentationFor detailed information, browse the sections below or visit our complete documentation:  Device Cloning Process - Complete guide to the cloning workflow  Firmware Uniqueness - How authenticity is achieved  Manual Donor Dump - Step-by-step manual extraction  Development Setup - Contributing and development guide  TUI Documentation - Interactive interface guide  Config space info - Config space shadow infoğŸ§¹ Cleanup &amp; Safety  Rebind donors: Use TUI/CLI to rebind donor devices to original drivers  Keep firmware private: Generated firmware contains real device identifiers  Use isolated build environments: Never build on production systems  Container cleanup: podman rmi pcileechfwgenerator:latest  Important: This tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.ğŸ† Acknowledgments  PCILeech Community: For feedback and contributions  @Simonrak for the writemask implementationğŸ“„ LicenseThis project is licensed under the Apache License - see the LICENSE file for details.âš ï¸ Legal NoticeAGAIN This tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.Security Considerations:  Never build firmware on systems used for production or sensitive operations  Use isolated build environments (Seperate dedicated hardware)  Keep generated firmware private and secure  Follow responsible disclosure practices for any security research  Use the SECURITY.md template to raise security concernsğŸ—‚ï¸ Site Navigation  ğŸ“‹ Site Map - Complete index of all documentation pages  ğŸ” Search - Search all documentation content  ğŸ“– API Documentation - Auto-generated Python API reference""
    },
    
  
    
    {
      "title"    : "Manual Donor Dump",
      "category" : "",
      "tags"     : "",
      "url"      : "/manual-donor-dump.html",
      "date"     : "",
      "content"  : ""OverviewWhat is a Donor Dump?A donor dump is a comprehensive snapshot of a physical PCI deviceâ€™s configuration and capabilities. The PCILeech Firmware Generator uses this information to create firmware that accurately emulates the donor deviceâ€™s behavior.Key Information Captured:            Component      Description      Purpose                  Device Identity      Vendor/Device IDs, Subsystem IDs, Revision      Device identification and driver matching              Configuration Space      Full 4KB extended PCI configuration      Complete device state and capabilities              Power Management      MPC/MPR values, power states      Power efficiency and compatibility              Capabilities      AER, MSI/MSI-X, vendor-specific      Advanced PCI features              Memory Layout      BAR sizes, Device Serial Number (DSN)      Memory mapping and addressing              Class Information      24-bit class code      Device type classification      When to Use Manual Process  Debugging: When automated tools fail or produce unexpected results  Custom Workflows: Integration with existing automation or CI/CD pipelines  Research: Understanding the donor extraction process in detail  Troubleshooting: Isolating issues in the firmware generation pipelinePrerequisitesSystem Requirements            Requirement      Linux                  OS Version      Any modern distribution              Privileges      Root access (sudo)              Shell      Bash/Zsh              Build Tools      GCC, Make, Kernel Headers      Quick Prerequisite CheckLinux:# Check if all prerequisites are availableecho \"Checking prerequisites...\"command -v gcc &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo \"âœ“ GCC available\" || echo \"âœ— GCC missing\"command -v make &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo \"âœ“ Make available\" || echo \"âœ— Make missing\"[ -d \"/lib/modules/$(uname -r)/build\" ] &amp;&amp; echo \"âœ“ Kernel headers available\" || echo \"âœ— Kernel headers missing\"[ \"$EUID\" -eq 0 ] &amp;&amp; echo \"âœ“ Running as root\" || echo \"âœ— Need root privileges\"Installing PrerequisitesDebian/Ubuntusudo apt-get update &amp;&amp; sudo apt-get install -y \\    linux-headers-$(uname -r) \\    build-essential \\    dkmsFedora/CentOS/RHELsudo dnf install -y \\    kernel-devel-$(uname -r) \\    gcc \\    make \\    dkmsArch Linux/Manjarosudo pacman -S --needed \\    linux-headers \\    base-devel \\    dkmsopenSUSEsudo zypper install -y \\    kernel-devel-$(uname -r) \\    gcc \\    make \\    dkmsLinux Manual ProcessStep 1: Device Discovery and ValidationFind Your Donor Device# List all PCI devices with detailed informationlspci -vv# Filter by device type (example: network controllers)lspci -vv | grep -A 20 \"Ethernet controller\"# Get specific device informationlspci -s 03:00.0 -vvValidate Device Accessibility# Check if device is bound to a driverlspci -k -s 03:00.0# Verify device is not in use by critical servicessystemctl status NetworkManager  # For network devicessystemctl status display-manager # For graphics devicesExtract BDF Information# Get BDF with domain informationDEVICE_BDF=$(lspci | grep \"Ethernet controller\" | head -1 | cut -d' ' -f1)FULL_BDF=\"0000:${DEVICE_BDF}\"echo \"Using device: ${FULL_BDF}\"Step 2: Build Environment SetupNavigate to Build Directory# Ensure we're in the correct directorycd \"$(dirname \"$0\")/../PCILeechFWGenerator/src/donor_dump\" || {    echo \"Error: Cannot find donor_dump directory\"    exit 1}# Verify required files exist[ -f \"Makefile\" ] || { echo \"Error: Makefile not found\"; exit 1; }[ -f \"donor_dump.c\" ] || { echo \"Error: Source file not found\"; exit 1; }Clean Build Environment# Clean any previous buildsmake clean# Verify kernel build environmentmake -n 2&gt;&amp;1 | grep -q \"No rule to make target\" &amp;&amp; {    echo \"Error: Kernel build environment not properly configured\"    exit 1}Build with Error Handling# Build the kernel module with verbose outputif ! make V=1; then    echo \"Build failed. Common issues:\"    echo \"1. Kernel headers mismatch: $(uname -r) vs $(ls /lib/modules/)\"    echo \"2. Missing dependencies: gcc, make, kernel-devel\"    echo \"3. Insufficient permissions\"    exit 1fi# Verify build artifacts[ -f \"donor_dump.ko\" ] || { echo \"Error: Module not built\"; exit 1; }echo \"âœ“ Module built successfully: $(ls -lh donor_dump.ko)\"Step 3: Module Loading and Device BindingPre-load Validation# Check if module is already loadedif lsmod | grep -q donor_dump; then    echo \"Warning: donor_dump module already loaded\"    sudo rmmod donor_dump || {        echo \"Error: Cannot unload existing module\"        exit 1    }fi# Verify device exists and is accessibleif ! lspci -s \"${DEVICE_BDF}\" &gt;/dev/null 2&gt;&amp;1; then    echo \"Error: Device ${FULL_BDF} not found\"    exit 1fiLoad Module with Comprehensive Error Handling# Load module with device bindingif ! sudo insmod donor_dump.ko bdf=\"${FULL_BDF}\"; then    echo \"Module load failed. Checking kernel logs...\"    dmesg | tail -20 | grep donor_dump    exit 1fi# Verify module loaded successfullyif ! lsmod | grep -q donor_dump; then    echo \"Error: Module not loaded despite successful insmod\"    exit 1fiecho \"âœ“ Module loaded successfully for device ${FULL_BDF}\"Verify Proc Interface# Check if proc file is created and accessibleif [ ! -r \"/proc/donor_dump\" ]; then    echo \"Error: /proc/donor_dump not accessible\"    echo \"Module may have loaded but device binding failed\"    sudo rmmod donor_dump    exit 1fiecho \"âœ“ Proc interface available\"Step 4: Data Extraction and ValidationExtract Raw Data# Read donor information with error checkingif ! DONOR_DATA=$(cat /proc/donor_dump 2&gt;/dev/null); then    echo \"Error: Cannot read donor information\"    sudo rmmod donor_dump    exit 1fi# Validate data completenessif [ -z \"$DONOR_DATA\" ]; then    echo \"Error: No donor data extracted\"    sudo rmmod donor_dump    exit 1fiecho \"âœ“ Donor data extracted ($(echo \"$DONOR_DATA\" | wc -l) lines)\"Save Raw Data with Metadata# Create output directory with timestampOUTPUT_DIR=\"donor_dumps/$(date +%Y%m%d_%H%M%S)_${DEVICE_BDF//:/_}\"mkdir -p \"$OUTPUT_DIR\"# Save raw data with metadata{    echo \"# Donor dump generated on $(date)\"    echo \"# Device: ${FULL_BDF}\"    echo \"# Kernel: $(uname -r)\"    echo \"# System: $(uname -a)\"    echo \"\"    echo \"$DONOR_DATA\"} &gt; \"${OUTPUT_DIR}/donor_info.txt\"echo \"âœ“ Raw data saved to ${OUTPUT_DIR}/donor_info.txt\"Convert to JSON with Validation# Enhanced JSON conversion with validationconvert_to_json() {    local input_file=\"$1\"    local output_file=\"$2\"        # Create JSON with proper escaping and validation    {        echo \"{\"        echo \"  \\\"metadata\\\": {\"        echo \"    \\\"generated_at\\\": \\\"$(date -Iseconds)\\\",\"        echo \"    \\\"device_bdf\\\": \\\"${FULL_BDF}\\\",\"        echo \"    \\\"kernel_version\\\": \\\"$(uname -r)\\\",\"        echo \"    \\\"generator_version\\\": \\\"manual-v1.0\\\"\"        echo \"  },\"        echo \"  \\\"device_info\\\": {\"                # Process each line, handling special characters        grep -v '^#' \"$input_file\" | while IFS=':' read -r key value; do            if [ -n \"$key\" ] &amp;&amp; [ -n \"$value\" ]; then                # Escape special characters in JSON                key=$(echo \"$key\" | sed 's/\"/\\\\\"/g' | xargs)                value=$(echo \"$value\" | sed 's/\"/\\\\\"/g' | xargs)                echo \"    \\\"$key\\\": \\\"$value\\\",\"            fi        done | sed '$ s/,$//'  # Remove trailing comma                echo \"  }\"        echo \"}\"    } &gt; \"$output_file\"        # Validate JSON syntax    if command -v python3 &gt;/dev/null 2&gt;&amp;1; then        if ! python3 -m json.tool \"$output_file\" &gt;/dev/null 2&gt;&amp;1; then            echo \"Warning: Generated JSON may be invalid\"            return 1        fi    fi        return 0}# Convert to JSONJSON_FILE=\"${OUTPUT_DIR}/donor_info.json\"if convert_to_json \"${OUTPUT_DIR}/donor_info.txt\" \"$JSON_FILE\"; then    echo \"âœ“ JSON file created: $JSON_FILE\"else    echo \"âš  JSON conversion completed with warnings\"fiStep 5: Cleanup and VerificationSafe Module Unloading# Unload module with verificationcleanup_module() {    if lsmod | grep -q donor_dump; then        if sudo rmmod donor_dump; then            echo \"âœ“ Module unloaded successfully\"        else            echo \"Warning: Module unload failed\"            echo \"Check: lsmod | grep donor_dump\"            echo \"Force remove: sudo rmmod -f donor_dump\"        fi    fi}# Set trap for cleanup on script exittrap cleanup_module EXITVerify Output Quality# Comprehensive output validationvalidate_donor_dump() {    local json_file=\"$1\"        echo \"Validating donor dump quality...\"        # Check required fields    local required_fields=(\"vendor_id\" \"device_id\" \"class_code\")    for field in \"${required_fields[@]}\"; do        if ! grep -q \"\\\"$field\\\"\" \"$json_file\"; then            echo \"Warning: Missing required field: $field\"        fi    done        # Check file size (should be reasonable)    local file_size=$(stat -f%z \"$json_file\" 2&gt;/dev/null || stat -c%s \"$json_file\" 2&gt;/dev/null)    if [ \"$file_size\" -lt 100 ]; then        echo \"Warning: Donor dump seems too small ($file_size bytes)\"    elif [ \"$file_size\" -gt 10000 ]; then        echo \"Warning: Donor dump seems unusually large ($file_size bytes)\"    else        echo \"âœ“ Donor dump size looks reasonable ($file_size bytes)\"    fi}validate_donor_dump \"$JSON_FILE\"Validation and TestingDonor Dump Quality ValidationComprehensive Validation Script#!/bin/bash# validate_donor_dump.sh - Comprehensive donor dump validationvalidate_donor_dump() {    local json_file=\"$1\"    local errors=0    local warnings=0        echo \"=== Donor Dump Validation Report ===\"    echo \"File: $json_file\"    echo \"Generated: $(date)\"    echo \"\"        # Check file existence and readability    if [ ! -f \"$json_file\" ]; then        echo \"âŒ ERROR: File does not exist\"        return 1    fi        if [ ! -r \"$json_file\" ]; then        echo \"âŒ ERROR: File is not readable\"        return 1    fi        # Validate JSON syntax    if command -v jq &gt;/dev/null 2&gt;&amp;1; then        if ! jq empty \"$json_file\" 2&gt;/dev/null; then            echo \"âŒ ERROR: Invalid JSON syntax\"            ((errors++))        else            echo \"âœ“ JSON syntax valid\"        fi    else        echo \"âš  WARNING: jq not available, skipping JSON validation\"        ((warnings++))    fi        # Check required fields    local required_fields=(        \".device_info.vendor_id\"        \".device_info.device_id\"        \".metadata.device_bdf\"    )        for field in \"${required_fields[@]}\"; do        if command -v jq &gt;/dev/null 2&gt;&amp;1; then            if [ \"$(jq -r \"$field // empty\" \"$json_file\")\" = \"\" ]; then                echo \"âŒ ERROR: Missing required field: $field\"                ((errors++))            else                echo \"âœ“ Required field present: $field\"            fi        fi    done        # Validate field formats    if command -v jq &gt;/dev/null 2&gt;&amp;1; then        # Check vendor_id format (4 hex digits)        vendor_id=$(jq -r '.device_info.vendor_id // empty' \"$json_file\")        if [[ ! \"$vendor_id\" =~ ^[0-9A-Fa-f]{4}$ ]]; then            echo \"âŒ ERROR: Invalid vendor_id format: $vendor_id\"            ((errors++))        fi                # Check device_id format (4 hex digits)        device_id=$(jq -r '.device_info.device_id // empty' \"$json_file\")        if [[ ! \"$device_id\" =~ ^[0-9A-Fa-f]{4}$ ]]; then            echo \"âŒ ERROR: Invalid device_id format: $device_id\"            ((errors++))        fi                # Check BDF format        bdf=$(jq -r '.metadata.device_bdf // empty' \"$json_file\")        if [[ ! \"$bdf\" =~ ^[0-9A-Fa-f]{4}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}\\.[0-9A-Fa-f]$ ]]; then            echo \"âš  WARNING: Unusual BDF format: $bdf\"            ((warnings++))        fi    fi        # File size checks    local file_size=$(stat -f%z \"$json_file\" 2&gt;/dev/null || stat -c%s \"$json_file\" 2&gt;/dev/null)    if [ \"$file_size\" -lt 200 ]; then        echo \"âš  WARNING: File seems small ($file_size bytes) - may be incomplete\"        ((warnings++))    elif [ \"$file_size\" -gt 50000 ]; then        echo \"âš  WARNING: File seems large ($file_size bytes) - may contain unexpected data\"        ((warnings++))    fi        echo \"\"    echo \"=== Validation Summary ===\"    echo \"Errors: $errors\"    echo \"Warnings: $warnings\"        if [ \"$errors\" -eq 0 ]; then        echo \"âœ… Validation PASSED\"        return 0    else        echo \"âŒ Validation FAILED\"        return 1    fi}# Usage: validate_donor_dump \"path/to/donor_info.json\"Integration TestingTest with PCILeech Generator#!/bin/bash# test_donor_integration.sh - Test donor dump with PCILeechtest_donor_integration() {    local donor_file=\"$1\"    local test_board=\"${2:-pcileech_35t325_x1}\"    local test_bdf=\"${3:-0000:03:00.0}\"        echo \"Testing donor dump integration...\"        # Validate donor file first    if ! validate_donor_dump \"$donor_file\"; then        echo \"âŒ Donor dump validation failed\"        return 1    fi        # Test dry-run with PCILeech generator    if command -v pcileech-generate &gt;/dev/null 2&gt;&amp;1; then        echo \"Testing with PCILeech generator (dry-run)...\"        if pcileech-generate \\            --bdf \"$test_bdf\" \\            --board \"$test_board\" \\            --donor-info-file \"$donor_file\" \\            --dry-run; then            echo \"âœ… Integration test PASSED\"            return 0        else            echo \"âŒ Integration test FAILED\"            return 1        fi    else        echo \"âš  PCILeech generator not available, skipping integration test\"        return 0    fi}TroubleshootingCommon Issues and SolutionsLinux-Specific Issues1. Kernel Headers Mismatch# Problem: Headers don't match running kernel# Solution: Install correct headers or use DKMS# Check current kernel vs available headersecho \"Running kernel: $(uname -r)\"echo \"Available headers:\"ls /lib/modules/*/build 2&gt;/dev/null || echo \"No headers found\"# Fix with DKMS (recommended)sudo apt-get install dkmssudo dkms add ./donor_dumpsudo dkms build donor_dump/1.0sudo dkms install donor_dump/1.02. Module Loading Failures# Comprehensive module debuggingdebug_module_load() {    local module_path=\"$1\"    local bdf=\"$2\"        echo \"Debugging module load for $module_path with BDF $bdf\"        # Check module dependencies    echo \"Module info:\"    modinfo \"$module_path\"        # Check for conflicting modules    echo \"Checking for conflicts:\"    lsmod | grep -E \"(pci|donor)\"        # Attempt load with verbose logging    echo \"Loading with verbose logging:\"    sudo insmod \"$module_path\" bdf=\"$bdf\" debug=1        # Check kernel logs    echo \"Recent kernel messages:\"    dmesg | tail -20}3. Device Access Issues# Check device binding and driver conflictscheck_device_binding() {    local bdf=\"$1\"        echo \"Device binding status for $bdf:\"        # Check current driver    if [ -d \"/sys/bus/pci/devices/$bdf\" ]; then        echo \"Device exists in sysfs\"                if [ -L \"/sys/bus/pci/devices/$bdf/driver\" ]; then            current_driver=$(readlink \"/sys/bus/pci/devices/$bdf/driver\" | xargs basename)            echo \"Current driver: $current_driver\"                        # Suggest unbinding if necessary            echo \"To unbind: echo '$bdf' | sudo tee /sys/bus/pci/devices/$bdf/driver/unbind\"        else            echo \"No driver bound\"        fi    else        echo \"âŒ Device not found in sysfs\"    fi}Performance OptimizationBatch Processing Multiple Devices#!/bin/bash# batch_donor_dump.sh - Process multiple devices efficientlybatch_donor_dump() {    local device_list=\"$1\"  # File with one BDF per line    local output_dir=\"$2\"        mkdir -p \"$output_dir\"        # Build module once    echo \"Building donor_dump module...\"    if ! make -C src/donor_dump; then        echo \"âŒ Module build failed\"        return 1    fi        # Process each device    while IFS= read -r bdf; do        [ -z \"$bdf\" ] &amp;&amp; continue        [[ \"$bdf\" =~ ^#.*$ ]] &amp;&amp; continue  # Skip comments                echo \"Processing device: $bdf\"                # Create device-specific output directory        device_dir=\"$output_dir/${bdf//:/_}\"        mkdir -p \"$device_dir\"                # Load module for this device        if sudo insmod src/donor_dump/donor_dump.ko bdf=\"$bdf\"; then            # Extract data            cat /proc/donor_dump &gt; \"$device_dir/donor_info.txt\"                        # Convert to JSON            convert_to_json \"$device_dir/donor_info.txt\" \"$device_dir/donor_info.json\"                        # Unload module            sudo rmmod donor_dump                        echo \"âœ“ Completed: $bdf\"        else            echo \"âŒ Failed: $bdf\"        fi                # Brief pause to avoid overwhelming the system        sleep 1    done &lt; \"$device_list\"}Advanced UsageCustom Data ExtractionExtended Information Gathering# Enhanced donor dump with additional system contextcreate_extended_donor_dump() {    local bdf=\"$1\"    local output_file=\"$2\"        # Standard donor dump    cat /proc/donor_dump &gt; \"${output_file}.raw\"        # Add system context    {        echo \"=== EXTENDED DONOR DUMP ===\"        echo \"Generated: $(date -Iseconds)\"        echo \"System: $(uname -a)\"        echo \"BDF: $bdf\"        echo \"\"                echo \"=== DEVICE INFORMATION ===\"        lspci -vvv -s \"${bdf#0000:}\"        echo \"\"                echo \"=== SYSTEM PCI TREE ===\"        lspci -tv        echo \"\"                echo \"=== IOMMU GROUPS ===\"        find /sys/kernel/iommu_groups/ -name \"*\" -type l | \\            xargs -I {} sh -c 'echo \"Group $(basename $(dirname {})): $(basename $(readlink {}))\"' | \\            grep \"$bdf\" || echo \"No IOMMU group found\"        echo \"\"                echo \"=== DONOR DUMP DATA ===\"        cat \"${output_file}.raw\"            } &gt; \"$output_file\"}Automation IntegrationCI/CD Pipeline Integration# .github/workflows/donor-dump-validation.ymlname: Donor Dump Validationon:  push:    paths:      - 'donor_dumps/**'      - 'src/donor_dump/**'jobs:  validate:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v3            - name: Install dependencies        run: |          sudo apt-get update          sudo apt-get install -y jq                - name: Validate donor dumps        run: |          for dump in donor_dumps/*.json; do            echo \"Validating $dump\"            ./scripts/validate_donor_dump.sh \"$dump\"          doneSecurity ConsiderationsSafe Module Handling# Secure module loading with verificationsecure_module_load() {    local module_path=\"$1Automation IntegrationCI/CD Pipeline Integration# .github/workflows/donor-dump-validation.ymlname: Donor Dump Validationon:  push:    paths:      - 'donor_dumps/**'      - 'src/donor_dump/**'jobs:  validate:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v3            - name: Install dependencies        run: |          sudo apt-get update          sudo apt-get install -y jq                - name: Validate donor dumps        run: |          for dump in donor_dumps/*.json; do            echo \"Validating $dump\"            ./scripts/validate_donor_dump.sh \"$dump\"          doneSecurity ConsiderationsSafe Module Handling# Secure module loading with verificationsecure_module_load() {    local module_path=\"$1\"    local bdf=\"$2\"        # Verify module signature (if available)    if command -v modinfo &gt;/dev/null 2&gt;&amp;1; then        modinfo \"$module_path\" | grep -q \"signature\" &amp;&amp; echo \"âœ“ Module is signed\"    fi        # Check module for suspicious content    if command -v strings &gt;/dev/null 2&gt;&amp;1; then        if strings \"$module_path\" | grep -qE \"(rm -rf|format|delete)\"; then            echo \"âš  WARNING: Module contains potentially dangerous strings\"            read -p \"Continue anyway? (y/N): \" -n 1 -r            echo            [[ ! $REPLY =~ ^[Yy]$ ]] &amp;&amp; return 1        fi    fi        # Load with restricted permissions    sudo insmod \"$module_path\" bdf=\"$bdf\"}Privilege Management# Check and minimize required privilegescheck_privileges() {    if [ \"$EUID\" -ne 0 ]; then        echo \"This script requires root privileges for:\"        echo \"- Loading kernel modules\"        echo \"- Accessing PCI configuration space\"        echo \"- Reading /proc interfaces\"        echo \"\"        echo \"Run with: sudo $0\"        exit 1    fi        # Drop privileges where possible    if command -v sudo &gt;/dev/null 2&gt;&amp;1; then        ORIGINAL_USER=\"${SUDO_USER:-$USER}\"        echo \"Running as root, will drop privileges where possible\"    fi}Best Practices SummaryDevelopment Workflow  Always validate prerequisites before starting  Use version control for donor dump files  Document device-specific quirks in metadata  Test with multiple board types when possible  Maintain backup copies of working donor dumpsProduction Deployment  Automate validation in CI/CD pipelines  Use secure module signing in production  Monitor for kernel compatibility issues  Implement rollback procedures for failed dumps  Log all operations for audit trailsPerformance Optimization  Batch process multiple devices when possible  Cache build artifacts to avoid rebuilds  Use parallel processing for validation  Minimize module load/unload cycles  Implement smart retry logic for transient failuresConclusionThis enhanced manual donor dump generation guide provides:  Comprehensive error handling for robust operation  Cross-platform support for Linux and Windows  Validation and testing frameworks for quality assurance  Performance optimizations for batch processing  Security considerations for safe operation  Integration examples for automation workflowsThe manual process gives you complete control over donor dump generation, making it ideal for:  Debugging automated tool failures  Research and development of new features  Custom integration with existing workflows  Educational purposes to understand the processFor most users, the automated pcileech.py command or TUI interface remains the recommended approach, but this manual process provides a powerful alternative when needed.Quick ReferenceEssential CommandsLinux:# Quick donor dumpcd PCILeechFWGenerator/src/donor_dumpmake &amp;&amp; sudo insmod donor_dump.ko bdf=0000:03:00.0cat /proc/donor_dump &gt; donor_info.txtsudo rmmod donor_dumpFile Locations  Linux module source: src/donor_dump/  Validation tools: scripts/validate_donor_dump.sh  Output directory: donor_dumps/YYYYMMDD_HHMMSS_BDF/Support Resources  Main documentation: Home  TUI guide: TUI README  Development guide: Development  Firmware uniqueness: Firmware Uniqueness""
    },
    
  
    
    {
      "title"    : "Search",
      "category" : "",
      "tags"     : "",
      "url"      : "/search/",
      "date"     : "",
      "content"  : ""    ""
    },
    
  
    
    {
      "title"    : "Site Map",
      "category" : "",
      "tags"     : "",
      "url"      : "/sitemap.html",
      "date"     : "",
      "content"  : ""# Site Map## ğŸ  Main Pages- [Home](/) - PCILeech Firmware Generator overview and quick start- [Search](/search) - Search all documentation## ğŸ”§ Core Features & Architecture- [Device Cloning Process](device-cloning) - Learn about the device cloning workflow- [Configuration Space Shadow](config-space-shadow) - Understanding the configuration space shadow mechanism  - [Template Architecture](template-architecture) - Explore the template-based design system- [Firmware Authenticity & Stability](firmware-uniqueness) - Ensuring firmware integrity and reliability- [Supported Devices](supported-devices) - View all compatible hardware devices## ğŸ“š Guides & Tutorials- [Manual Donor Dump](manual-donor-dump) - How to manually create donor device dumps- [TUI Interface Guide](tui-readme) - Using the Terminal User Interface- [Development Guide](development) - Contributing to PCILeech Firmware Generator## ğŸ“– API Documentation- [Python API Documentation](docs/) - Auto-generated Sphinx documentation## ğŸ”— External Resources- [PCILeech Main Project](https://github.com/ufrisk/pcileech) - Visit the main PCILeech project- [PCILeech FPGA](https://github.com/ufrisk/pcileech-fpga) - PCILeech FPGA implementation- [Issues Tracker](https://github.com/ramseymcgrath/PCILeechFWGenerator/issues) - Report bugs or request features- [Community Forum](https://github.com/ramseymcgrath/PCILeechFWGenerator/discussions) - Join the community discussions---*Last updated: {{ site.time | date: \"%Y-%m-%d\" }}*""
    },
    
  
    
    {
      "title"    : "Supported Devices",
      "category" : "",
      "tags"     : "",
      "url"      : "/supported-devices.html",
      "date"     : "",
      "content"  : ""# Supported DevicesPCILeech Firmware Generator supports a wide range of PCIe devices as donors for firmware generation. This page provides detailed information about device compatibility, requirements, and recommendations.## Device Categories### Network Interface Cards (NICs)Network cards are excellent donors due to their simple PCIe implementation and widespread availability.**Recommended Models:**- **Realtek RTL8111/8168/8411** - Common Gigabit Ethernet controllers- **Intel 82574L/82579LM** - Enterprise-grade NICs with good documentation- **Broadcom NetXtreme** - High-performance network controllers### Audio DevicesSound cards and audio interfaces provide good donor material with well-documented PCIe implementations.**Recommended Models:**- **Creative Sound Blaster** series - Professional audio cards- **ASUS Xonar** series - High-quality audio interfaces- **M-Audio** interfaces - Professional audio equipment- **Generic USB audio controllers** - Simple PCIe-to-USB bridges### Capture CardsVideo capture devices offer diverse PCIe configurations and are readily available.**Recommended Models:**- **Blackmagic DeckLink** series - Professional video capture- **AVerMedia Live Gamer** series - Gaming capture cards- **Elgato Capture Cards** - Streaming-focused devices- **Hauppauge WinTV** series - TV tuner cards### Other Suitable DevicesVarious other PCIe devices can serve as effective donors.**Additional Categories:**- **SATA/SAS Controllers** - Storage interface cards- **USB 3.0/3.1 Controllers** - PCIe-to-USB expansion cards- **Serial/Parallel Port Cards** - Legacy interface adapters- **GPIO/Digital I/O Cards** - Industrial control interfaces## Device Requirements### Hardware Requirements- **PCIe Interface** - Must be a standard PCIe device (not PCIe-to-PCI bridges)- **Standard Form Factor** - x1, x4, x8, or x16 slots supported- **Accessible Configuration Space** - Device must respond to PCIe configuration reads- **VFIO Compatible** - Must be bindable to VFIO driver### Software Requirements- **Linux IOMMU Support** - Device must be in a separate IOMMU group- **VFIO Driver Binding** - Must support vfio-pci driver binding- **Configuration Space Access** - Full 4KB configuration space must be readable## Device Selection Guidelines### Ideal Donor Characteristics1. **Simple Implementation** - Devices with straightforward PCIe logic2. **Good Documentation** - Well-documented devices are easier to analyze3. **Standard Compliance** - Devices that follow PCIe specifications closely4. **Stable Operation** - Devices that don't require complex initialization### Devices to Avoid- **On-board Devices** - Integrated audio, network, or storage controllers- **Critical System Components** - Graphics cards, primary storage controllers- **Complex Multi-function Devices** - Devices with multiple PCIe functions- **Proprietary Implementations** - Devices with non-standard PCIe behavior## Compatibility Testing### Pre-selection VerificationBefore using a device as a donor, verify compatibility:```bash# Check device PCIe configurationlspci -vvv -s [device_id]# Verify IOMMU group isolation./vfio_check.py [device_id]# Test VFIO bindingsudo ./force_vfio_binds.sh [device_id]```### Configuration AnalysisThe generator analyzes several key aspects of donor devices:- **Vendor/Device ID** - Unique device identification- **Configuration Space Layout** - Register organization and capabilities- **BAR Configuration** - Memory and I/O resource requirements- **MSI/MSI-X Support** - Interrupt handling capabilities- **Power Management** - PCIe power states and control## Target FPGA Boards### Supported PCILeech BoardsThe generator supports firmware generation for these PCILeech-compatible boards:- **pcileech_75t484_x1** - Xilinx Spartan-7 XC7S75T, x1 PCIe- **pcileech_35t325_x4** - Xilinx Spartan-6 XC6SLX25, x4 PCIe- **pcileech_100t484_x1** - Xilinx Spartan-7 XC7S100T, x1 PCIe### Board-specific ConsiderationsEach target board has specific resource constraints:- **Logic Resources** - LUT and flip-flop availability- **Memory Resources** - Block RAM for configuration space shadow- **I/O Resources** - PCIe transceivers and general-purpose I/O- **Clock Resources** - PCIe clock domains and user clocks## Troubleshooting Device Issues### Common Problems1. **VFIO Binding Failures** - Device in use by another driver2. **IOMMU Group Conflicts** - Device shares IOMMU group with critical components3. **Configuration Space Errors** - Incomplete or corrupted configuration data4. **Power Management Issues** - Device doesn't respond after power state changes### Diagnostic ToolsUse the included tools to diagnose device issues:```bash# Comprehensive device analysis./vfio_setup_checker.py --device [device_id] --verbose# Interactive troubleshooting./vfio_setup_checker.py --interactive# Generate automated fix scripts./vfio_setup_checker.py --generate-script```## Best Practices### Security Considerations- **Isolated Testing** - Use dedicated hardware for donor analysis- **Firmware Privacy** - Keep generated firmware private and secure- **Clean Environment** - Use isolated build environments### Performance Optimization- **Device Selection** - Choose devices with appropriate complexity- **Resource Planning** - Consider target board resource constraints- **Testing Methodology** - Implement comprehensive testing procedures### Development Workflow1. **Device Identification** - Catalog available donor devices2. **Compatibility Testing** - Verify VFIO and IOMMU compatibility3. **Configuration Analysis** - Extract and analyze device configuration4. **Firmware Generation** - Generate custom firmware for target board5. **Validation Testing** - Test generated firmware functionality## Contributing Device Support### Adding New DevicesTo add support for new device types:1. **Test Compatibility** - Verify device works with existing tools2. **Document Configuration** - Record device-specific requirements3. **Submit Examples** - Provide working configuration examples4. **Update Documentation** - Add device to compatibility lists### Reporting IssuesWhen reporting device compatibility issues:1. **Provide Device Information** - Include lspci output and device details2. **Include Error Messages** - Capture complete error logs3. **Describe Environment** - Document system configuration4. **Test Isolation** - Verify issue isn't system-specific---For more information about device selection and configuration, see the [Device Cloning Guide](device-cloning) and [Development Setup](development) documentation.""
    },
    
  
    
    {
      "title"    : "Template Architecture",
      "category" : "",
      "tags"     : "",
      "url"      : "/template-architecture.html",
      "date"     : "",
      "content"  : ""# PCIe Capabilities and Template ArchitectureThis document describes the PCIe capabilities handled by the PCILeech Firmware Generator and provides detailed information about how the SystemVerilog templates are created, filled, and integrated into the final firmware.## OverviewThe PCILeech Firmware Generator creates authentic PCIe device firmware by analyzing real donor hardware and generating comprehensive SystemVerilog implementations. The system handles multiple PCIe capabilities and features through a sophisticated template-based architecture.The generation process involves three main phases:1. **Device Analysis**: Extract configuration space, capabilities, and behavior from donor devices2. **Context Building**: Assemble comprehensive template context from all data sources3. **Template Rendering**: Generate SystemVerilog modules using Jinja2 templates## Supported PCIe Capabilities### 1. Configuration Space Shadow (4KB BRAM)The configuration space shadow is the foundation of PCIe device emulation, providing complete 4KB configuration space emulation in FPGA block RAM.**Key Features:**- **Full 4KB Configuration Space**: Complete emulation of standard and extended configuration space- **Dual-Port Access**: Simultaneous read/write operations for performance- **Overlay RAM**: Dedicated storage for writable fields (Command/Status registers)- **Automatic Initialization**: Populated from real donor device data or synthetic generation- **Hardware Integration**: Seamless integration with PCIe core configuration interface**Implementation Details:**- Main configuration space stored in BRAM (`config_space_ram[0:1023]`)- Overlay RAM for writable fields (`overlay_ram[0:OVERLAY_ENTRIES-1]`)- State machine handles PCIe configuration TLP processing- Automatic overlay mapping detects writable registers from PCIe specifications```systemverilog// Configuration Space Shadow parametersparameter CONFIG_SPACE_SIZE = 4096;parameter OVERLAY_ENTRIES = 64;parameter DUAL_PORT = 1;```### 2. MSI-X (Message Signaled Interrupts Extended)MSI-X provides scalable interrupt handling with up to 2048 interrupt vectors, essential for modern PCIe devices.**MSI-X Table Structure:**- **Message Address Lower (32-bit)**: Target memory address for interrupt message- **Message Address Upper (32-bit)**: Upper 32 bits for 64-bit addressing- **Message Data (32-bit)**: Interrupt payload data- **Vector Control (32-bit)**: Mask bit and reserved fields**Features Implemented:**- **Parameterized Table Size**: 1-2048 vectors based on donor device- **BRAM-based Table Storage**: Efficient memory usage with block RAM attributes- **Pending Bit Array (PBA)**: Tracks pending interrupts for masked vectors- **Interrupt Delivery Logic**: Validates vectors and delivers interrupts- **Byte-Enable Support**: Granular write access to table entries**Template Integration:**```systemverilog// MSI-X Table parameters derived from donor deviceparameter NUM_MSIX = {{ NUM_MSIX }};parameter MSIX_TABLE_BIR = {{ MSIX_TABLE_BIR }};parameter MSIX_TABLE_OFFSET = {{ MSIX_TABLE_OFFSET }};parameter MSIX_PBA_BIR = {{ MSIX_PBA_BIR }};parameter MSIX_PBA_OFFSET = {{ MSIX_PBA_OFFSET }};```### 3. Power Management CapabilityPower management enables PCIe devices to transition between different power states (D0, D1, D2, D3hot, D3cold).**Power States Supported:**- **D0**: Fully operational state- **D3hot**: Low power state with auxiliary power- **D3cold**: No power state (requires external power cycling)**Implementation Features:**- **PMCSR Register**: Power Management Control and Status Register- **PME Support**: Power Management Event signaling- **State Transitions**: Automatic timeout-based transitions- **Minimal Resource Usage**:  Dict[str, Any]:```#### Context Assembly Process1. **Device Identifiers**: Extract vendor/device IDs, class codes, revision2. **Configuration Space Context**: Process 4KB configuration space data3. **MSI-X Context**: Parse MSI-X table and PBA information4. **BAR Configuration**: Analyze BAR sizes, types, and memory regions5. **Timing Configuration**: Apply manufacturing variance and timing parameters6. **Overlay Mapping**: Generate writable register overlay mappings### 3. Template Processing Pipeline#### Phase 1: Analysis and Extraction1. **Device Binding**: Bind donor device to VFIO driver2. **Configuration Space Reading**: Extract 4KB configuration space3. **Capability Walking**: Parse and analyze PCIe capabilities4. **BAR Analysis**: Determine BAR sizes and types5. **MSI-X Table Reading**: Extract MSI-X table data if present#### Phase 2: Context Generation1. **Device Profile Creation**: Generate device configuration structure2. **Capability Mapping**: Map capabilities to template parameters3. **Overlay Mapping**: Determine writable register overlays4. **Manufacturing Variance**: Apply deterministic timing variations5. **Template Context Assembly**: Combine all data sources#### Phase 3: Template Rendering1. **Template Selection**: Choose appropriate templates based on device type2. **Context Injection**: Apply template context to Jinja2 templates3. **Code Generation**: Generate SystemVerilog modules4. **File Integration**: Create project files and build scripts### 4. Overlay Mapping SystemThe overlay mapping system automatically detects writable registers in PCIe configuration space:```pythonclass OverlayMapper:    def detect_overlay_registers(        self, config_space: Dict[int, int], capabilities: Dict[str, int]    ) -> List[Tuple[int, int]]:        \"\"\"        Detect registers that need overlay RAM for writable fields.        Returns list of (offset, mask) tuples for overlay entries.        \"\"\"```**Overlay Detection Process:**1. **Standard Register Analysis**: Check Command/Status, BAR, and capability registers2. **Capability-Specific Overlays**: MSI-X, Power Management, PCIe Express registers3. **Mask Generation**: Create bit-level masks for writable fields4. **Validation**: Ensure overlay mappings are consistent with PCIe specifications## SystemVerilog Module Hierarchy### 1. Top-Level Module- **pcileech_top**: Main wrapper module- **Responsibilities**: Clock/reset distribution, PCIe interface, module instantiation- **Template**: `top_level_wrapper.sv.j2`### 2. Core Controller- **pcileech_tlps128_bar_controller**: Main device controller- **Responsibilities**: TLP processing, BAR management, capability coordination- **Template**: `pcileech_tlps128_bar_controller.sv.j2`### 3. Configuration Space Shadow- **pcileech_tlps128_cfgspace_shadow**: Configuration space implementation- **Responsibilities**: Config space access, overlay management, capability registers- **Template**: `cfg_shadow.sv.j2`### 4. MSI-X Subsystem- **msix_table**: MSI-X table and PBA implementation- **Responsibilities**: Interrupt table management, vector delivery, masking- **Template**: `msix_table.sv.j2`### 5. Power Management- **pmcsr_stub**: Power management implementation- **Responsibilities**: D-state transitions, PME handling, power control- **Template**: `pmcsr_stub.sv.j2`### 6. Memory Regions- **region_device_ctrl**: Device control region- **region_data_buffer**: Data buffer region- **region_custom_pio**: Custom PIO region- **Templates**: Various region-specific templates## Configuration Space Structure### Standard Configuration Space (0x00-0xFF)- **0x00-0x03**: Vendor ID / Device ID- **0x04-0x07**: Command / Status- **0x08-0x0B**: Class Code / Revision ID- **0x0C-0x0F**: Cache Line Size / Latency Timer / Header Type / BIST- **0x10-0x27**: Base Address Registers (BARs 0-5)- **0x28-0x2B**: Cardbus CIS Pointer- **0x2C-0x2F**: Subsystem Vendor ID / Subsystem ID- **0x30-0x33**: Expansion ROM Base Address- **0x34-0x3B**: Capabilities Pointer / Reserved- **0x3C-0x3F**: Interrupt Line / Pin / Min_Gnt / Max_Lat### Capability Structures (0x40-0xFF)- **0x40-0x47**: Power Management Capability- **0x48-0x4F**: MSI Capability (if not using MSI-X)- **0x50-0x5B**: MSI-X Capability (if supported)- **0x60-0x9F**: PCIe Express Capability### Extended Configuration Space (0x100-0xFFF)- **0x100-0x2FF**: MSI-X Table (if supported)- **0x300-0x3FF**: MSI-X PBA (if supported)- **0x400-0xFFF**: Extended capabilities and vendor-specific regions## Memory Organization### BAR Memory Layout```textBAR0 Memory Map (example):0x0000-0x00FF: Device Control Region0x0100-0x01FF: Status Registers0x0200-0x03FF: Data Buffer0x0400-0x0FFF: Custom PIO Region0x1000-0x1FFF: MSI-X Table (if applicable)0x2000-0x2FFF: MSI-X PBA (if applicable)```### BRAM Allocation- **Configuration Space**: 4KB block RAM for complete config space- **Overlay RAM**: Variable size based on writable register count- **MSI-X Table**: Sized based on interrupt vector count- **Data Buffers**: Parameterized based on device requirements## Build Integration### 1. Project File GenerationThe template system generates complete Vivado project files:- **TCL Scripts**: Project creation and configuration- **Constraint Files**: Timing and placement constraints- **Memory Initialization**: Configuration space and MSI-X table data### 2. Synthesis OptimizationTemplates include synthesis-specific optimizations:- **RAM Style Attributes**: Force block RAM inference- **Timing Constraints**: Critical path optimization- **Resource Sharing**: Efficient multiplexer generation### 3. Simulation SupportGenerated code includes simulation features:- **Testbench Integration**: Automatic test pattern generation- **Debug Outputs**: Comprehensive status and debug signals- **Assertion Checking**: SystemVerilog assertions for verification## Manufacturing Variance### Deterministic Variance ApplicationThe system applies realistic manufacturing variance to make generated firmware less detectable:```pythonclass ManufacturingVarianceSimulator:    def apply_timing_variance(        self, base_timing: float, variance_percent: float    ) -> float:        \"\"\"Apply deterministic timing variance based on device characteristics.\"\"\"```### Variance Categories1. **Clock Jitter**: 2-5% variation in clock timing2. **Register Timing**: 10-50ns jitter in register access3. **Power Noise**: 1-3% supply voltage variation effects4. **Process Variation**: 5-15% parameter variation5. **Temperature Drift**: 10-100 ppm/Â°C timing drift## Testing and Validation### Template Validation1. **Syntax Checking**: Validate generated SystemVerilog syntax2. **Simulation Testing**: Verify functionality with test patterns3. **Timing Analysis**: Ensure timing constraints are met4. **Resource Utilization**: Verify efficient FPGA resource usage### Capability Testing1. **Configuration Space Access**: Test all configuration registers2. **MSI-X Functionality**: Verify interrupt table operation3. **Power Management**: Test D-state transitions4. **BAR Access**: Validate memory region access patterns## Future Extensions### Planned Capabilities- **SR-IOV**: Single Root I/O Virtualization support- **AER**: Advanced Error Reporting capability- **ATS**: Address Translation Services- **ACS**: Access Control Services### Template System Enhancements- **Multi-Function Support**: Multiple PCIe functions per device- **Dynamic Reconfiguration**: Runtime capability modification- **Enhanced Debugging**: Improved debug and trace capabilities- **Performance Optimization**: Advanced timing and resource optimization---For more detailed information about specific capabilities, see the individual documentation pages for [Configuration Space Shadow](config-space-shadow), [MSI-X Implementation](msix-implementation), and [Device Cloning Process](device-cloning).""
    },
    
  
    
    {
      "title"    : "TUI Interface",
      "category" : "",
      "tags"     : "",
      "url"      : "/tui-readme.html",
      "date"     : "",
      "content"  : ""# ğŸ–¥ï¸ PCILeech Firmware Generator TUI[![PyPI version](https://badge.fury.io/py/pcileechfwgenerator.svg)](https://badge.fury.io/py/pcileechfwgenerator)[![Python Support](https://img.shields.io/pypi/pyversions/pcileechfwgenerator.svg)](https://pypi.org/project/pcileechfwgenerator/)[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)A modern Text User Interface (TUI) for the PCILeech firmware generation workflow, built with the Textual framework.---## ğŸ“‘ Table of Contents- [ğŸ” Overview](#-overview)- [ğŸš€ Installation](#-installation)  - [Prerequisites](#prerequisites)  - [Install TUI Dependencies](#install-tui-dependencies)- [ğŸ® Usage](#-usage)  - [Launch TUI Mode](#launch-tui-mode)  - [TUI Interface Overview](#tui-interface-overview)- [âœ¨ Features](#-features)  - [Device Management](#device-management)  - [Configuration Management](#configuration-management)  - [Build Monitoring](#build-monitoring)  - [System Integration](#system-integration)- [âš™ï¸ Configuration Profiles](#ï¸-configuration-profiles)  - [Profile Locations](#profile-locations)  - [Default Profiles](#default-profiles)  - [Creating Custom Profiles](#creating-custom-profiles)- [âŒ¨ï¸ Keyboard Shortcuts](#ï¸-keyboard-shortcuts)- [ğŸ”§ Error Handling](#-error-handling)  - [Common Errors and Solutions](#common-errors-and-solutions)- [ğŸš€ Advanced Features](#-advanced-features)  - [Behavior Profiling](#behavior-profiling)  - [System Status Monitoring](#system-status-monitoring)  - [Build Process Integration](#build-process-integration)  - [Configuration Validation](#configuration-validation)- [ğŸ› Troubleshooting](#-troubleshooting)  - [TUI Won't Start](#tui-wont-start)  - [Device Detection Issues](#device-detection-issues)  - [Build Failures](#build-failures)- [ğŸ› ï¸ Development](#ï¸-development)  - [Architecture](#architecture)  - [Key Components](#key-components)  - [Extending the TUI](#extending-the-tui)- [ğŸ¤ Contributing](#-contributing)- [ğŸ“„ License](#-license)- [âš ï¸ Disclaimer](#ï¸-disclaimer)---## ğŸ” OverviewThe TUI provides an interactive, user-friendly interface that addresses the key pain points of the command-line workflow:- **Enhanced Device Discovery**: Visual PCIe device browser with detailed information- **Guided Configuration**: Intuitive configuration wizard with validation- **Real-time Build Monitoring**: Live progress tracking with resource usage- **Error Guidance**: Intelligent error analysis with suggested fixes- **Profile Management**: Save and load configuration profiles## ğŸš€ Installation### Prerequisites- Python 3.9 or higher- Root/sudo access (required for device binding)- Podman container runtime- PCILeech firmware generation environment### Install TUI Dependencies```bash# Install TUI-specific dependenciespip install -r requirements-tui.txt# Or install individual packagespip install textual rich psutil watchdog pydantic```## ğŸ® Usage### Launch TUI ModeThere are several ways to launch the TUI:```bash# Method 1: Using the unified entrypoint (recommended)sudo python3 pcileech.py tui# Method 2: Direct execution sudo python3 -m src.tui.main# Method 3: Using the sudo wrapper (if installed)./install-sudo-wrapper.sh  # Install the wrapper first (one-time setup)pcileech-tui-sudo```> **Note**: UI operations require root privileges. The sudo wrapper script preserves the Python environment when running with sudo, preventing module import errors.### TUI Interface OverviewThe TUI is organized into several panels:#### 1. Device Selection Panel (Top Left)- Lists all detected PCIe devices- Shows device status, BDF address, name, driver, and IOMMU group- Provides device suitability indicators- Refresh and details buttons#### 2. Configuration Panel (Top Right)- Displays current build configuration- Shows board type, device type, and enabled features- Configure, load profile, and save profile buttons#### 3. Build Progress Panel (Middle)- Real-time build progress with stage tracking- Resource usage monitoring (CPU, memory, disk)- Build control buttons (start, pause, stop)- Log viewing capability#### 4. System Status Panel (Bottom Left)- Podman availability and status- Vivado detection and version- USB device count- Disk space information- Root access status#### 5. Quick Actions Panel (Bottom Right)- Device scanning- Output directory access- Build report viewing- Advanced settings- Documentation links## âœ¨ Features### Device Management- **Auto-discovery**: Automatically scans and lists PCIe devices- **Enhanced Information**: Shows vendor names, driver status, IOMMU groups- **Suitability Assessment**: Rates devices for firmware generation compatibility- **Driver Status**: Indicates if devices are bound to drivers### Configuration Management- **Profile System**: Save and load configuration profiles- **Default Profiles**: Pre-configured profiles for common scenarios:  - Network Device Standard  - Storage Device Optimized  - Quick Development  - Full Featured- **Validation**: Real-time configuration validation with error messages### Build Monitoring- **Stage Tracking**: Visual progress through 6 build stages:  1. Environment Validation  2. Device Analysis  3. Register Extraction  4. SystemVerilog Generation  5. Vivado Synthesis  6. Bitstream Generation- **Resource Monitoring**: Real-time CPU, memory, and disk usage- **Error Detection**: Automatic error detection with guided recovery### System Integration- **Backward Compatibility**: Maintains all existing CLI functionality- **Container Integration**: Seamless integration with Podman containers- **Log Management**: Integrated log viewing and analysis- **USB Device Support**: Automatic USB device detection for flashing## âš™ï¸ Configuration Profiles### Profile LocationsProfiles are stored in `~/.pcileech/profiles/` as JSON files.### Default Profiles#### Network Device Standard```json{  \"name\": \"Network Device Standard\",  \"board_type\": \"pcileech_35t325_x1\",  \"advanced_sv\": true,  \"enable_variance\": true,  \"behavior_profiling\": true,  \"profile_duration\": 30.0,  \"donor_dump\": true}```#### Quick Development```json{  \"name\": \"Quick Development\",  \"board_type\": \"pcileech_35t325_x1\",  \"advanced_sv\": false,  \"enable_variance\": false,  \"flash_after_build\": true,  \"donor_dump\": true}```#### Local Build```json{  \"name\": \"Local Build\",  \"board_type\": \"pcileech_35t325_x1\",  \"advanced_sv\": true,  \"enable_variance\": true,  \"donor_dump\": false,  \"local_build\": true,  \"donor_info_file\": \"~/.pcileech/donor_info.json\"}```### Creating Custom Profiles1. Configure settings in the TUI2. Click \"Save Profile\"3. Enter a profile name4. Profile is saved to `~/.pcileech/profiles/`## âŒ¨ï¸ Keyboard Shortcuts- `Ctrl+C`: Exit application- `Tab`: Navigate between panels- `Enter`: Activate selected button/item- `Space`: Toggle checkboxes- `â†‘/â†“`: Navigate lists and tables- `F1`: Help (if implemented)## ğŸ”§ Error HandlingThe TUI provides intelligent error analysis and guidance:### Common Errors and Solutions#### VFIO Binding Failed- **Cause**: IOMMU not enabled or vfio-pci module not loaded- **Solutions**:  - Enable IOMMU in BIOS  - Load vfio-pci module: `modprobe vfio-pci`  - Unbind current driver first#### Container Image Not Found- **Cause**: DMA firmware container not built- **Solutions**:  - The container is now automatically built when needed  - If automatic build fails, manually build with: `podman build -t dma-fw .`  - Check Podman installation and internet connectivity#### Insufficient Permissions- **Cause**: Not running with root privileges- **Solutions**:  - Run with sudo: `sudo python3 pcileech.py tui`  - Add user to required groups## ğŸš€ Advanced Features### Donor Device ConfigurationThe TUI provides options for configuring how donor device information is obtained:- **Default Mode**: By default, the system builds and uses the donor_dump kernel module to extract real device information from the selected PCIe device. This provides the most accurate firmware generation.- **Local Build Mode**: When enabled, this mode skips using the donor_dump kernel module and instead uses either:  - A previously saved donor information file (specified via the \"Donor Info File\" option)  - Synthetic donor information generated based on the selected device type**Configuration Options:**- **Donor Dump**: Enable/disable using the donor_dump kernel module (enabled by default)- **Local Build**: Enable to use a donor info file or synthetic data instead of a real device- **Donor Info File**: Path to a JSON file containing donor information from a previous run**Benefits of Local Build Mode:**- **No Kernel Module**: Useful in environments where building kernel modules is restricted- **No Physical Device**: Generate firmware without requiring the donor device to be present- **Reproducible Builds**: Use the same donor information across multiple builds**Usage:**1. Select a device in the Device Selection Panel2. Open the Configuration Panel3. To use the default mode (recommended), ensure \"Donor Dump\" is enabled4. To use Local Build mode:   - Enable \"Local Build\" option   - Disable \"Donor Dump\" option   - Optionally specify a \"Donor Info File\" path5. Start the build process![TUI Configuration Panel](../docs/images/tui_config_panel.png)### Behavior ProfilingThe TUI provides a seamless interface for enabling and configuring behavior profiling:- **Enable/Disable**: Toggle behavior profiling in the configuration panel- **Duration Control**: Set custom profiling duration (in seconds)- **Real-time Monitoring**: Track profiling progress in the build progress panel- **Profile Integration**: Automatically integrates profiling data into the build process**Configuration Options:**- **Behavior Profiling**: Enable/disable the profiling feature- **Profile Duration**: Set the duration for capturing device behavior (default: 30.0 seconds)- **Device Type**: Select specific device type for optimized profiling**Benefits:**- **Enhanced Realism**: Generated firmware mimics actual device behavior patterns- **Improved Timing**: More accurate register access timing based on real measurements- **Optimized Performance**: Device-specific optimizations based on observed behavior**Usage:**1. Select a device in the Device Selection Panel2. Open the Configuration Panel3. Enable \"Behavior Profiling\" option4. Adjust \"Profile Duration\" if needed5. Start the build processDuring the build, a dedicated \"Behavior Profiling\" stage will appear in the progress panel, showing real-time status of the profiling process.### System Status MonitoringThe TUI continuously monitors:- Podman service status- Vivado installation and version- Available USB devices- System resources (CPU, memory, disk)- VFIO support status### Build Process Integration- **Container Orchestration**: Manages Podman container lifecycle- **Progress Parsing**: Parses build output for progress indicators- **Resource Tracking**: Monitors system resource usage during builds- **Log Analysis**: Analyzes build logs for errors and warnings### Configuration Validation- **Real-time Validation**: Validates configuration as you type- **Compatibility Checks**: Warns about incompatible settings- **Resource Requirements**: Estimates resource requirements## ğŸ› Troubleshooting### TUI Won't Start1. **Check Dependencies**:   ```bash   pip install -r requirements-tui.txt   ```2. **Check Python Version**:   ```bash   python3 --version  # Should be 3.8+   ```3. **Check Terminal Compatibility**:   - Ensure terminal supports ANSI colors   - Try different terminal emulator### Device Detection Issues1. **Run as Root**:   ```bash   # Using the sudo wrapper (recommended)   ./install-sudo-wrapper.sh  # Install the wrapper first   pcileech-tui-sudo      # Or directly with sudo   sudo python3 pcileech.py tui   ```      > **Note**: When running with sudo, you might encounter the error `ModuleNotFoundError: No module named 'src'`. This happens because sudo changes the Python module search path. Use the provided sudo wrapper script to avoid this issue.2. **Check lspci**:   ```bash   lspci -Dnn   ```3. **Verify IOMMU**:   ```bash   dmesg | grep -i iommu   ```### Build Failures1. **Check Container Image**:   ```bash   podman images | grep dma-fw   ```2. **Verify Device Binding**:   ```bash   ls -la /dev/vfio/   ```3. **Check Logs**:   - Use \"View Logs\" button in TUI   - Check `generate.log` file## ğŸ› ï¸ Development### ArchitectureThe TUI follows a modular architecture:```src/tui/â”œâ”€â”€ main.py              # Main applicationâ”œâ”€â”€ models/              # Data modelsâ”œâ”€â”€ core/                # Business logic servicesâ”œâ”€â”€ widgets/             # Custom UI widgetsâ”œâ”€â”€ screens/             # Screen componentsâ””â”€â”€ styles/              # CSS styling```### Key Components- **DeviceManager**: PCIe device discovery and management- **ConfigManager**: Configuration and profile management- **BuildOrchestrator**: Build process orchestration- **StatusMonitor**: System status monitoring### Extending the TUI1. **Add New Widgets**: Create custom widgets in `src/tui/widgets/`2. **Add New Screens**: Create screen components in `src/tui/screens/`3. **Extend Models**: Add new data models in `src/tui/models/`4. **Add Services**: Create new services in `src/tui/core/`## ğŸ¤ Contributing1. Follow the existing code structure2. Add type hints to all functions3. Include docstrings for public methods4. Test with various PCIe devices5. Ensure backward compatibility## ğŸ“„ LicenseSame as the main PCILeech project.## âš ï¸ DisclaimerThis tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.---**Version 0.5.0** - Major release with TUI interface and professional packaging""
    },
    
  
    
    {
      "title"    : "Donor Info Template",
      "category" : "",
      "tags"     : "",
      "url"      : "/donor-info-template.html",
      "date"     : "",
      "content"  : ""# Donor Info TemplateThe Donor Info Template feature allows you to generate comprehensive JSON templates for capturing detailed device information, behavioral profiles, and advanced configuration parameters. This enables more precise device cloning and optimization.## OverviewThe donor info template is a structured JSON file that captures:- Device identification and capabilities- Behavioral profiling data- Timing characteristics- Access patterns- Interrupt and DMA configurations- PCILeech-specific optimizations- Manufacturing variance data## Generating a Template### Using the CLIGenerate a donor info template using the command line:```bash# Generate comprehensive template with all fieldspython3 -c \"from src.device_clone.donor_info_template import DonorInfoTemplateGeneratorfrom pathlib import PathDonorInfoTemplateGenerator.save_template(Path('donor_info_template.json'))\"# Generate minimal template with only essential fieldspython3 -c \"from src.device_clone.donor_info_template import DonorInfoTemplateGeneratorfrom pathlib import Pathtemplate = DonorInfoTemplateGenerator.generate_minimal_template()DonorInfoTemplateGenerator.save_template_dict(template, Path('minimal_template.json'))\"# Pre-fill template with device information (requires sudo and valid device)python3 -c \"from src.device_clone.donor_info_template import DonorInfoTemplateGeneratorfrom pathlib import Pathgenerator = DonorInfoTemplateGenerator()template = generator.generate_template_from_device('0000:03:00.0')DonorInfoTemplateGenerator.save_template_dict(template, Path('device_template.json'))\"# Validate an existing donor info filepython3 -c \"from src.device_clone.donor_info_template import DonorInfoTemplateGeneratorgenerator = DonorInfoTemplateGenerator()is_valid, errors = generator.validate_template_file('my_device.json')if not is_valid:    for error in errors:        print(f'Error: {error}')else:    print('Template is valid')\"```### Generating Template During BuildCurrently, template generation is handled separately from the build process. To integrate behavioral profiling data:```bash# First generate the template from device discoverypython3 -c \"from src.device_clone.donor_info_template import DonorInfoTemplateGeneratorgenerator = DonorInfoTemplateGenerator()template = generator.generate_template_from_device('0000:03:00.0')DonorInfoTemplateGenerator.save_template_dict(template, Path('device_template.json'))\"# Then use existing behavioral profiling during buildsudo python3 pcileech.py build --bdf 0000:03:00.0 --board pcileech_35t325_x1 --enable-behavioral-profiling```This approach allows you to:- Get detailed device information from lspci and sysfs- Capture behavioral data during the build process- Maintain separate templates for different device configurations- Combine discovered and behavioral data for optimal firmware generation### Using the TUICurrently, template generation through the TUI would need to be implemented. For now, use the programmatic approach:```pythonfrom src.device_clone.donor_info_template import DonorInfoTemplateGeneratorfrom pathlib import Path# Generate and save templateDonorInfoTemplateGenerator.save_template(Path(\"donor_info_template.json\"))```### Programmatic Usage```pythonfrom src.device_clone.donor_info_template import DonorInfoTemplateGenerator# Generate full template dictionarytemplate = DonorInfoTemplateGenerator.generate_blank_template()# Generate minimal template dictionaryminimal_template = DonorInfoTemplateGenerator.generate_minimal_template()# Save to fileDonorInfoTemplateGenerator.save_template(\"my_template.json\", pretty=True)```## Template Types### Full TemplateThe default template includes comprehensive sections for:- Complete device identification and capabilities- Behavioral profiling and timing characteristics- Access patterns and interrupt configurations- DMA characteristics and performance profiles- Advanced features (virtualization, security, error handling)- PCILeech-specific optimizations- Manufacturing variance dataUse the full template when you need:- Detailed behavioral profiling- Advanced performance tuning- Complete device emulation- Manufacturing variance simulation### Minimal TemplateThe minimal template (generated with `generate_minimal_template()`) includes only essential fields:- Basic device identification (vendor/device IDs, class code)- Core PCIe capabilities (version, link width/speed)- BAR configurationUse the minimal template when you need:- Quick device cloning without advanced features- Simple device identification- Basic functionality testing- A starting point for custom configurations## Template StructureThe template contains the following main sections:### 1. MetadataContains information about when and how the template was generated:```json{  \"metadata\": {    \"generated_at\": \"2025-01-19T12:30:45Z\",    \"device_bdf\": \"\",  // Fill in: e.g., \"0000:03:00.0\"    \"kernel_version\": \"\",  // Fill in: e.g., \"6.1.0-15-amd64\"    \"generator_version\": \"enhanced-v2.0\",    \"behavioral_data_included\": true,    \"profile_capture_duration\": null,  // Fill in: seconds    \"comments\": \"\"  // Any additional notes  }}```### 2. Device InfoComprehensive device identification and configuration:```json{  \"device_info\": {    \"identification\": {      \"vendor_id\": null,  // e.g., 0x8086 for Intel      \"device_id\": null,      \"subsystem_vendor_id\": null,      \"subsystem_device_id\": null,      \"class_code\": null,  // e.g., 0x020000 for Ethernet      \"revision_id\": null,      \"device_name\": \"\",  // Human-readable name      \"manufacturer\": \"\"    },    \"capabilities\": {      \"max_payload_size\": null,  // 128, 256, 512, etc.      \"link_width\": null,  // 1, 2, 4, 8, 16      \"link_speed\": \"\",  // \"2.5GT/s\", \"5GT/s\", etc.      \"supports_msi\": null,      \"msi_vectors\": null,      \"supports_msix\": null,      \"msix_vectors\": null,      // ... more capabilities    },    \"bars\": [      {        \"bar_number\": 0,        \"type\": \"\",  // \"memory\" or \"io\"        \"size\": null,  // size in bytes        \"prefetchable\": null,  // true/false        \"64bit\": null,  // true/false        \"purpose\": \"\",  // Description of BAR usage        \"typical_access_pattern\": \"\"  // \"sequential\", \"random\", etc.      }      // User should duplicate this structure for each BAR (1-5)    ]  }}```### 3. Behavioral ProfileCaptures runtime behavior and performance characteristics:```json{  \"behavioral_profile\": {    \"timing_characteristics\": {      \"register_access_latency_us\": {        \"min\": null,        \"max\": null,        \"average\": null,        \"std_deviation\": null      },      \"interrupt_response_time_us\": {        \"min\": null,        \"max\": null,        \"average\": null      },      // ... more timing data    },    \"access_patterns\": {      \"frequent_registers\": [        {          \"offset\": null,          \"name\": \"\",          \"access_count\": null,          \"read_write_ratio\": null,          \"typical_values\": []        }      ],      // ... access sequences and patterns    },    \"interrupt_patterns\": {      \"interrupt_type\": \"\",  // \"msi\", \"msix\", or \"intx\"      \"vector_count\": null,      \"coalescing_enabled\": null,      // ... interrupt configuration    },    \"dma_characteristics\": {      \"supports_dma\": null,      \"max_dma_size_bytes\": null,      \"scatter_gather_support\": null,      // ... DMA configuration    }  }}```### 4. PCILeech OptimizationsSpecific optimizations for PCILeech firmware:```json{  \"pcileech_optimizations\": {    \"recommended_payload_size\": null,    \"optimal_read_strategy\": \"\",  // \"burst\", \"sequential\", etc.    \"optimal_write_strategy\": \"\",    \"tlp_processing_hints\": {      \"prefer_32bit_addresses\": null,      \"support_64bit_addresses\": null,      \"max_outstanding_requests\": null,      \"completion_timeout_us\": null    },    \"memory_window_strategy\": {      \"window_size\": null,      \"window_count\": null,      \"access_pattern\": \"\"  // \"linear\", \"random\", etc.    }  }}```### 5. Advanced FeaturesSupport for virtualization, security, and performance features:```json{  \"advanced_features\": {    \"virtualization\": {      \"sr_iov_capable\": null,      \"max_vfs\": null,      // ... SR-IOV configuration    },    \"security_features\": {      \"ats_support\": null,      \"pri_support\": null,      \"pasid_support\": null,      // ... security features    },    \"error_handling\": {      \"aer_support\": null,      \"ecrc_support\": null,      // ... error handling    },    \"performance_features\": {      \"relaxed_ordering\": null,      \"no_snoop\": null,      // ... performance features    }  }}```## Filling Out the Template### Step 1: Basic Device InformationStart by filling in the device identification:- Use `lspci -nn` to get vendor/device IDs- Use `lspci -vvv` for detailed capability information- Check `/sys/bus/pci/devices/[BDF]/` for additional details### Step 2: Behavioral ProfilingRun behavioral profiling to capture timing and access patterns:```bash# Enable behavioral profiling in your buildsudo python3 pcileech.py build --bdf 0000:03:00.0 --board pcileech_35t325_x1 --enable-behavioral-profiling```### Step 3: Manual TestingFor advanced features:- Test interrupt behavior under load- Measure DMA transfer characteristics- Profile register access patterns- Document any device-specific quirks### Step 4: ValidationValidate your completed template:- Ensure all critical fields are filled- Test with actual device cloning- Verify timing parameters are realistic- Document any assumptions or limitations## Using the Completed TemplateOnce filled out, the donor info template can be used for:1. **Advanced Device Cloning**: Provide the template during build for optimized firmware2. **Performance Tuning**: Use timing data to optimize access patterns3. **Compatibility Testing**: Share templates for similar devices4. **Documentation**: Maintain a library of device profiles### Using Templates During BuildCurrently, templates can be used for override and merge operations using the programmatic interface:```pythonfrom src.device_clone.donor_info_template import DonorInfoTemplateGenerator# Load template and merge with discovered valuestemplate = DonorInfoTemplateGenerator.load_template(\"my_device_profile.json\")# Use template during build process for value overrides```When using templates during build:- Template values override any discovered values when there's a conflict- Null values in the template are ignored (discovered values are used)- This allows you to selectively override specific device characteristics- The template provides additional behavioral and configuration dataExample scenarios:```bash# Override device IDs while keeping discovered BAR configuration# (set device IDs in template, leave BARs as null)# Implementation would be in the build system integration# Use template and also output a new template with merged values# This functionality would be added to the build orchestrator```## Best Practices1. **Version Control**: Keep templates in version control to track changes2. **Device Variations**: Create separate templates for different device revisions3. **Testing**: Validate templates with actual hardware before production use4. **Documentation**: Add detailed comments in the \"comments\" field5. **Sharing**: Consider contributing templates for common devices## Troubleshooting### Common Issues1. **Invalid JSON**: Use a JSON validator to check syntax2. **Missing Required Fields**: Some fields may be required for specific features3. **Incorrect Data Types**: Ensure numbers aren't quoted as strings4. **Timing Values**: Use appropriate units (microseconds, milliseconds)### Getting Help- Check existing templates for examples- Use the template validation methods for field explanations- Consult device datasheets for capability details- Ask in community forums for device-specific guidance## Related Documentation- [Device Cloning](/device-cloning.html)- [Behavioral Profiling](/firmware-uniqueness.html)- [Manual Donor Dump](/manual-donor-dump.html)- [Template Architecture](/template-architecture.html)""
    }
    
  
]
